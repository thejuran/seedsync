# Copyright 2017, Inderpreet Singh, All rights reserved.

import json
import logging
import time
from threading import Event
from typing import List, Tuple
from urllib.parse import unquote

from bottle import HTTPResponse, request

from common import overrides
from controller import Controller
from ..web_app import IHandler, WebApp


logger = logging.getLogger(__name__)


class WebResponseActionCallback(Controller.Command.ICallback):
    """
    Controller action callback used by model streams to wait for action
    status.
    Clients should call wait() method to wait for the status,
    then query the status from 'success', 'error', and 'error_code'
    """

    def __init__(self):
        self.__event = Event()
        self.success = None
        self.error = None
        self.error_code = 400

    @overrides(Controller.Command.ICallback)
    def on_failure(self, error: str, error_code: int = 400):
        self.success = False
        self.error = error
        self.error_code = error_code
        self.__event.set()

    @overrides(Controller.Command.ICallback)
    def on_success(self):
        self.success = True
        self.__event.set()

    def wait(self, timeout: float = None) -> bool:
        """
        Wait for the command to complete.

        Args:
            timeout: Maximum time to wait in seconds. None means wait forever.

        Returns:
            True if the event was set (command completed), False if timed out.
        """
        return self.__event.wait(timeout=timeout)


class ControllerHandler(IHandler):
    def __init__(self, controller: Controller):
        self.__controller = controller

    @overrides(IHandler)
    def add_routes(self, web_app: WebApp):
        web_app.add_handler("/server/command/queue/<file_name>", self.__handle_action_queue)
        web_app.add_handler("/server/command/stop/<file_name>", self.__handle_action_stop)
        web_app.add_handler("/server/command/extract/<file_name>", self.__handle_action_extract)
        web_app.add_handler("/server/command/delete_local/<file_name>", self.__handle_action_delete_local)
        web_app.add_handler("/server/command/delete_remote/<file_name>", self.__handle_action_delete_remote)
        web_app.add_post_handler("/server/command/bulk", self.__handle_bulk_command)

    def __handle_action_queue(self, file_name: str):
        """
        Request a QUEUE action
        :param file_name:
        :return:
        """
        # value is double encoded
        file_name = unquote(file_name)

        command = Controller.Command(Controller.Command.Action.QUEUE, file_name)
        callback = WebResponseActionCallback()
        command.add_callback(callback)
        self.__controller.queue_command(command)
        callback.wait()
        if callback.success:
            return HTTPResponse(body="Queued file '{}'".format(file_name))
        else:
            return HTTPResponse(body=callback.error, status=callback.error_code)

    def __handle_action_stop(self, file_name: str):
        """
        Request a STOP action
        :param file_name:
        :return:
        """
        # value is double encoded
        file_name = unquote(file_name)

        command = Controller.Command(Controller.Command.Action.STOP, file_name)
        callback = WebResponseActionCallback()
        command.add_callback(callback)
        self.__controller.queue_command(command)
        callback.wait()
        if callback.success:
            return HTTPResponse(body="Stopped file '{}'".format(file_name))
        else:
            return HTTPResponse(body=callback.error, status=callback.error_code)

    def __handle_action_extract(self, file_name: str):
        """
        Request a EXTRACT action
        :param file_name:
        :return:
        """
        # value is double encoded
        file_name = unquote(file_name)

        command = Controller.Command(Controller.Command.Action.EXTRACT, file_name)
        callback = WebResponseActionCallback()
        command.add_callback(callback)
        self.__controller.queue_command(command)
        callback.wait()
        if callback.success:
            return HTTPResponse(body="Requested extraction for file '{}'".format(file_name))
        else:
            return HTTPResponse(body=callback.error, status=callback.error_code)

    def __handle_action_delete_local(self, file_name: str):
        """
        Request a DELETE LOCAL action
        :param file_name:
        :return:
        """
        # value is double encoded
        file_name = unquote(file_name)

        command = Controller.Command(Controller.Command.Action.DELETE_LOCAL, file_name)
        callback = WebResponseActionCallback()
        command.add_callback(callback)
        self.__controller.queue_command(command)
        callback.wait()
        if callback.success:
            return HTTPResponse(body="Requested local delete for file '{}'".format(file_name))
        else:
            return HTTPResponse(body=callback.error, status=callback.error_code)

    def __handle_action_delete_remote(self, file_name: str):
        """
        Request a DELETE REMOTE action
        :param file_name:
        :return:
        """
        # value is double encoded
        file_name = unquote(file_name)

        command = Controller.Command(Controller.Command.Action.DELETE_REMOTE, file_name)
        callback = WebResponseActionCallback()
        command.add_callback(callback)
        self.__controller.queue_command(command)
        callback.wait()
        if callback.success:
            return HTTPResponse(body="Requested remote delete for file '{}'".format(file_name))
        else:
            return HTTPResponse(body=callback.error, status=callback.error_code)

    # Valid action names for the bulk endpoint
    _VALID_ACTIONS = {
        "queue": Controller.Command.Action.QUEUE,
        "stop": Controller.Command.Action.STOP,
        "extract": Controller.Command.Action.EXTRACT,
        "delete_local": Controller.Command.Action.DELETE_LOCAL,
        "delete_remote": Controller.Command.Action.DELETE_REMOTE,
    }

    # Timeout per file in seconds for bulk operations
    _BULK_TIMEOUT_PER_FILE = 5.0
    # Maximum total timeout for bulk operations in seconds
    _BULK_MAX_TIMEOUT = 300.0
    # Maximum number of files allowed in a single bulk request
    _MAX_BULK_FILES = 1000

    def __handle_bulk_command(self):
        """
        Handle bulk command requests for multiple files.

        Expected JSON body:
        {
            "action": "queue|stop|extract|delete_local|delete_remote",
            "files": ["file1", "file2", ...]
        }

        Returns JSON:
        {
            "results": [
                {"file": "file1", "success": true},
                {"file": "file2", "success": false, "error": "error message", "error_code": 404}
            ],
            "summary": {
                "total": 2,
                "succeeded": 1,
                "failed": 1
            }
        }
        """
        # Parse JSON body
        try:
            body = request.json
        except Exception:
            return HTTPResponse(
                body=json.dumps({"error": "Invalid JSON body"}),
                status=400,
                content_type="application/json"
            )

        if not body:
            return HTTPResponse(
                body=json.dumps({"error": "Request body is required"}),
                status=400,
                content_type="application/json"
            )

        # Validate action
        action_name = body.get("action")
        if not action_name or action_name not in self._VALID_ACTIONS:
            valid_actions = ", ".join(self._VALID_ACTIONS.keys())
            return HTTPResponse(
                body=json.dumps({
                    "error": "Invalid action '{}'. Valid actions: {}".format(action_name, valid_actions)
                }),
                status=400,
                content_type="application/json"
            )

        # Validate files array
        files = body.get("files")
        if not files:
            return HTTPResponse(
                body=json.dumps({"error": "files array is required and must not be empty"}),
                status=400,
                content_type="application/json"
            )
        if not isinstance(files, list):
            return HTTPResponse(
                body=json.dumps({"error": "files must be an array"}),
                status=400,
                content_type="application/json"
            )
        if not all(isinstance(f, str) and f.strip() for f in files):
            return HTTPResponse(
                body=json.dumps({"error": "All files must be non-empty strings"}),
                status=400,
                content_type="application/json"
            )

        # Deduplicate files while preserving order
        files = list(dict.fromkeys(files))

        # Enforce maximum file limit to prevent DoS
        if len(files) > self._MAX_BULK_FILES:
            return HTTPResponse(
                body=json.dumps({
                    "error": "Too many files. Maximum {} files allowed per request".format(
                        self._MAX_BULK_FILES
                    )
                }),
                status=400,
                content_type="application/json"
            )

        action = self._VALID_ACTIONS[action_name]

        # Process files using parallel queuing for performance
        results, succeeded, failed = self._process_bulk_commands(action, files, action_name)

        response = {
            "results": results,
            "summary": {
                "total": len(files),
                "succeeded": succeeded,
                "failed": failed
            }
        }

        return HTTPResponse(
            body=json.dumps(response),
            status=200,
            content_type="application/json"
        )

    def _process_bulk_commands(
        self,
        action: Controller.Command.Action,
        files: List[str],
        action_name: str
    ) -> Tuple[List[dict], int, int]:
        """
        Process bulk commands with parallel queuing for improved performance.

        Instead of queuing one command and waiting for it to complete before
        queuing the next, this method queues ALL commands first, allowing the
        controller to process them in a single batch. This significantly reduces
        latency for large file counts.

        Args:
            action: The action to perform on all files.
            files: List of file names to process.
            action_name: Human-readable action name for logging.

        Returns:
            Tuple of (results list, succeeded count, failed count).
        """
        start_time = time.time()
        file_count = len(files)

        logger.info("Bulk {} operation started for {} file(s)".format(action_name, file_count))

        # Calculate timeout: per-file timeout with a maximum cap
        timeout = min(
            file_count * self._BULK_TIMEOUT_PER_FILE,
            self._BULK_MAX_TIMEOUT
        )

        # Phase 1: Queue all commands (parallel queuing)
        commands_with_callbacks: List[Tuple[str, WebResponseActionCallback]] = []
        for file_name in files:
            command = Controller.Command(action, file_name)
            callback = WebResponseActionCallback()
            command.add_callback(callback)
            self.__controller.queue_command(command)
            commands_with_callbacks.append((file_name, callback))

        queue_time = time.time()
        logger.debug("Bulk {}: queued {} commands in {:.3f}s".format(
            action_name, file_count, queue_time - start_time
        ))

        # Phase 2: Wait for all callbacks to complete
        # The controller will process all queued commands in its next cycle,
        # so waiting for all at once is much faster than waiting one-by-one.
        results = []
        succeeded = 0
        failed = 0
        timed_out = 0

        # Calculate remaining time for each callback
        for file_name, callback in commands_with_callbacks:
            remaining_timeout = max(0.1, timeout - (time.time() - start_time))
            completed = callback.wait(timeout=remaining_timeout)

            if not completed:
                # Timed out waiting for this command
                results.append({
                    "file": file_name,
                    "success": False,
                    "error": "Operation timed out",
                    "error_code": 504
                })
                failed += 1
                timed_out += 1
            elif callback.success:
                results.append({
                    "file": file_name,
                    "success": True
                })
                succeeded += 1
            else:
                results.append({
                    "file": file_name,
                    "success": False,
                    "error": callback.error,
                    "error_code": callback.error_code
                })
                failed += 1

        total_time = time.time() - start_time

        # Log performance summary
        if timed_out > 0:
            logger.warning(
                "Bulk {} completed: {}/{} succeeded, {} failed, {} timed out in {:.3f}s".format(
                    action_name, succeeded, file_count, failed - timed_out, timed_out, total_time
                )
            )
        else:
            logger.info(
                "Bulk {} completed: {}/{} succeeded in {:.3f}s ({:.1f} files/sec)".format(
                    action_name, succeeded, file_count, total_time,
                    file_count / total_time if total_time > 0 else 0
                )
            )

        return results, succeeded, failed
