---
phase: 27-webhook-import-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/python/controller/webhook_manager.py
  - src/python/web/handler/webhook.py
  - src/python/controller/__init__.py
  - src/python/controller/controller.py
  - src/python/seedsync.py
  - src/python/web/web_app_builder.py
  - src/python/tests/unittests/test_controller/test_controller_unit.py
  - src/python/tests/unittests/test_controller/test_auto_delete.py
  - src/python/tests/unittests/test_controller/test_sonarr_manager.py
  - src/python/controller/sonarr_manager.py
  - src/python/tests/unittests/test_controller/test_webhook_manager.py
  - src/python/tests/unittests/test_web/test_webhook_handler.py
autonomous: true

must_haves:
  truths:
    - "POST /server/webhook/sonarr receives Sonarr import events and enqueues them"
    - "POST /server/webhook/radarr receives Radarr import events and enqueues them"
    - "Webhook events flow through same import pipeline (persist, badge, toast, auto-delete)"
    - "SonarrManager polling code is fully removed (webhook-only architecture)"
    - "Webhook endpoints return 200 for all valid event types including Test"
    - "All existing Controller unit tests pass with WebhookManager mocks"
  artifacts:
    - path: "src/python/controller/webhook_manager.py"
      provides: "WebhookManager class with queue.Queue, enqueue_import(), and process()"
      min_lines: 30
    - path: "src/python/web/handler/webhook.py"
      provides: "WebhookHandler with POST routes for /server/webhook/sonarr and /server/webhook/radarr"
      min_lines: 50
    - path: "src/python/tests/unittests/test_controller/test_webhook_manager.py"
      provides: "Unit tests for WebhookManager"
      min_lines: 40
    - path: "src/python/tests/unittests/test_web/test_webhook_handler.py"
      provides: "Unit tests for WebhookHandler"
      min_lines: 60
  key_links:
    - from: "src/python/web/handler/webhook.py"
      to: "src/python/controller/webhook_manager.py"
      via: "WebhookHandler calls webhook_manager.enqueue_import()"
      pattern: "enqueue_import"
    - from: "src/python/controller/controller.py"
      to: "src/python/controller/webhook_manager.py"
      via: "Controller.__check_webhook_imports() calls webhook_manager.process()"
      pattern: "webhook_manager\\.process"
    - from: "src/python/seedsync.py"
      to: "src/python/controller/webhook_manager.py"
      via: "seedsync.py creates WebhookManager and passes to both Controller and WebAppBuilder"
      pattern: "WebhookManager"
---

<objective>
Replace the polling-based SonarrManager with a webhook-driven WebhookManager. Create POST
webhook endpoints for Sonarr and Radarr that enqueue import events via a thread-safe queue.
Wire WebhookManager into Controller and WebAppBuilder. Remove SonarrManager entirely. Update
all existing tests and add new tests for WebhookManager and WebhookHandler.

Purpose: Instant import detection via webhooks instead of 60s polling latency. Adds Radarr
import detection. Eliminates outbound API calls from SeedSync.

Output: Working webhook backend -- POST /server/webhook/sonarr and /server/webhook/radarr
endpoints that trigger the existing import pipeline (persist, badge, toast, auto-delete).
All Python tests passing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-webhook-import-detection/27-RESEARCH.md

@src/python/controller/sonarr_manager.py
@src/python/controller/controller.py
@src/python/controller/__init__.py
@src/python/seedsync.py
@src/python/web/web_app_builder.py
@src/python/web/web_app.py
@src/python/web/handler/controller.py
@src/python/tests/unittests/test_controller/test_controller_unit.py
@src/python/tests/unittests/test_controller/test_auto_delete.py
@src/python/tests/unittests/test_controller/test_sonarr_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebhookManager and WebhookHandler, wire into app</name>
  <files>
    src/python/controller/webhook_manager.py
    src/python/web/handler/webhook.py
    src/python/controller/__init__.py
    src/python/controller/controller.py
    src/python/seedsync.py
    src/python/web/web_app_builder.py
    src/python/controller/sonarr_manager.py
    src/python/tests/unittests/test_controller/test_sonarr_manager.py
  </files>
  <action>
    **Create `src/python/controller/webhook_manager.py`:**

    Create a WebhookManager class that mirrors the Manager pattern used by ScanManager, LftpManager, etc.
    It owns a `queue.Queue` for receiving import events from the web thread and a `process()` method
    called by the Controller thread to drain the queue and return matched file names.

    Implementation (follow the code from research Pattern 1 exactly):
    - `__init__(self, context)`: Store context, create logger as `context.logger.getChild("WebhookManager")`,
      create `self.__import_queue = Queue()` for `(source: str, file_name: str)` tuples.
    - `enqueue_import(self, source: str, file_name: str)`: Put tuple on queue, log at INFO level:
      `"{} webhook import enqueued: '{}'".format(source, file_name)`
    - `process(self, model_file_names: Set[str]) -> List[str]`: Drain queue via `get_nowait()` while
      `not self.__import_queue.empty()`. For each `(source, file_name)`, do case-insensitive matching
      against `model_file_names` (build `{name.lower(): name for name in model_file_names}` lookup dict).
      If matched, append original model file name to `newly_imported` list and log at INFO. If not matched,
      log at DEBUG. Return `newly_imported`.

    Thread-safety note: `queue.Queue` is thread-safe by design. `enqueue_import()` is called from web
    server thread. `process()` is called from controller thread.

    ---

    **Create `src/python/web/handler/webhook.py`:**

    Create a WebhookHandler class following the IHandler pattern from `web/handler/controller.py`.

    Implementation (follow research Pattern 2 exactly):
    - Import: `json`, `os`, `logging`, `bottle.HTTPResponse`, `bottle.request`, `common.overrides`,
      `controller.webhook_manager.WebhookManager`, `..web_app.IHandler`, `..web_app.WebApp`
    - Module-level logger: `logger = logging.getLogger(__name__)`
    - `__init__(self, webhook_manager: WebhookManager)`: Store webhook_manager.
    - `add_routes(self, web_app: WebApp)` with `@overrides(IHandler)`: Register two POST routes:
      `web_app.add_post_handler("/server/webhook/sonarr", self.__handle_sonarr_webhook)`
      `web_app.add_post_handler("/server/webhook/radarr", self.__handle_radarr_webhook)`
    - `__handle_sonarr_webhook(self)`: Calls `self._handle_webhook("Sonarr", self._extract_sonarr_title)`
    - `__handle_radarr_webhook(self)`: Calls `self._handle_webhook("Radarr", self._extract_radarr_title)`
    - `_handle_webhook(self, source: str, extract_title_fn) -> HTTPResponse`:
      - Try `body = request.json`, catch Exception -> return 400 "Invalid JSON"
      - If not body -> return 400 "Empty body"
      - Get `event_type = body.get("eventType", "")`
      - If `event_type == "Test"` -> log INFO, return 200 "Test OK"
      - If `event_type != "Download"` -> return 200 "OK" (ignore non-import events)
      - Extract title via `extract_title_fn(body)`. If empty -> return 200 "OK"
      - Call `self.__webhook_manager.enqueue_import(source, title)` -> return 200 "OK"
      - **CRITICAL**: Always return 200 for valid event types to prevent Sonarr/Radarr retry behavior.
        Only return 400 for genuinely malformed requests (invalid JSON, empty body).
    - `_extract_sonarr_title(body: dict) -> str` (static method):
      Fallback chain: `episodeFile.sourcePath` (extract `os.path.basename`) -> `release.releaseTitle` ->
      `series.title`. Return empty string if nothing found.
    - `_extract_radarr_title(body: dict) -> str` (static method):
      Fallback chain: `movieFile.sourcePath` (extract `os.path.basename`) -> `release.releaseTitle` ->
      `movie.title`. Return empty string if nothing found.

    ---

    **Modify `src/python/controller/__init__.py`:**

    - Remove line: `from .sonarr_manager import SonarrManager`
    - Add line: `from .webhook_manager import WebhookManager`

    ---

    **Modify `src/python/controller/controller.py`:**

    1. Remove import: `from .sonarr_manager import SonarrManager` (line 15)
    2. Add import: `from .webhook_manager import WebhookManager`
    3. Change `__init__` signature from `def __init__(self, context, persist)` to
       `def __init__(self, context, persist, webhook_manager)` -- add `webhook_manager` as third parameter.
    4. Replace line 129 (`self.__sonarr_manager = SonarrManager(context=self.__context)`) with:
       `self.__webhook_manager = webhook_manager`
       Note: WebhookManager is NOT created inside Controller. It's passed in as a parameter because it
       must be shared with WebAppBuilder. This follows the same pattern as `persist` being passed in.
    5. In `process()` method (line 207), replace `self.__check_sonarr_imports()` with
       `self.__check_webhook_imports()`
    6. Rename `__check_sonarr_imports` method (line 669) to `__check_webhook_imports`.
       Change the body:
       - Replace `newly_imported = self.__sonarr_manager.process(model_file_names)` with
         `newly_imported = self.__webhook_manager.process(model_file_names)`
       - Change log message from `"Recorded Sonarr import: '{}'"` to
         `"Recorded webhook import: '{}'"` (line 681)
       Everything else in the method body stays identical (persist, badge update, auto-delete scheduling).

    ---

    **Modify `src/python/seedsync.py`:**

    1. Add import: `from controller.webhook_manager import WebhookManager` (after existing controller imports
       on line 19)
    2. In `run()` method, BEFORE creating Controller (line 115):
       Add: `webhook_manager = WebhookManager(self.context)`
    3. Change Controller creation (line 115) from:
       `controller = Controller(self.context, self.controller_persist)`
       to:
       `controller = Controller(self.context, self.controller_persist, webhook_manager)`
    4. Change WebAppBuilder creation (line 121) from:
       `web_app_builder = WebAppBuilder(self.context, controller, self.auto_queue_persist)`
       to:
       `web_app_builder = WebAppBuilder(self.context, controller, self.auto_queue_persist, webhook_manager)`

    ---

    **Modify `src/python/web/web_app_builder.py`:**

    1. Add import: `from .handler.webhook import WebhookHandler` (after existing handler imports)
    2. Change `__init__` signature to add `webhook_manager` parameter:
       `def __init__(self, context, controller, auto_queue_persist, webhook_manager):`
    3. In `__init__`, after `self.status_handler = StatusHandler(context.status)` (line 32), add:
       `self.webhook_handler = WebhookHandler(webhook_manager)`
    4. In `build()` method, BEFORE `web_app.add_default_routes()` (line 55), add:
       `self.webhook_handler.add_routes(web_app)`
       This must come BEFORE `add_default_routes()` because default routes act as catch-all.

    ---

    **Delete `src/python/controller/sonarr_manager.py`:**

    Delete this file entirely. It is replaced by webhook_manager.py.

    ---

    **Delete `src/python/tests/unittests/test_controller/test_sonarr_manager.py`:**

    Delete this file entirely. SonarrManager tests are replaced by new WebhookManager tests in Task 2.
  </action>
  <verify>
    Run: `cd /Users/julianamacbook/seedsync/src/python && python -c "from controller.webhook_manager import WebhookManager; print('WebhookManager import OK')"`
    Run: `cd /Users/julianamacbook/seedsync/src/python && python -c "from web.handler.webhook import WebhookHandler; print('WebhookHandler import OK')"`
    Run: `cd /Users/julianamacbook/seedsync/src/python && python -c "from controller import WebhookManager; print('__init__ export OK')"`
    Verify sonarr_manager.py no longer exists: `test ! -f /Users/julianamacbook/seedsync/src/python/controller/sonarr_manager.py && echo "DELETED OK"`
    Verify test_sonarr_manager.py no longer exists: `test ! -f /Users/julianamacbook/seedsync/src/python/tests/unittests/test_controller/test_sonarr_manager.py && echo "DELETED OK"`
    Verify no remaining references to SonarrManager in production code (tests updated in Task 2):
    `grep -r "SonarrManager" /Users/julianamacbook/seedsync/src/python/controller/ /Users/julianamacbook/seedsync/src/python/web/ /Users/julianamacbook/seedsync/src/python/seedsync.py || echo "No SonarrManager refs - CLEAN"`
  </verify>
  <done>
    WebhookManager and WebhookHandler created with correct implementations. Controller uses
    webhook_manager.process() instead of sonarr_manager.process(). seedsync.py creates shared
    WebhookManager and passes to both Controller and WebAppBuilder. SonarrManager file and its
    tests deleted. All imports resolve without error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update existing tests and add new WebhookManager/WebhookHandler tests</name>
  <files>
    src/python/tests/unittests/test_controller/test_controller_unit.py
    src/python/tests/unittests/test_controller/test_auto_delete.py
    src/python/tests/unittests/test_controller/test_webhook_manager.py
    src/python/tests/unittests/test_web/test_webhook_handler.py
  </files>
  <action>
    **Update `src/python/tests/unittests/test_controller/test_controller_unit.py`:**

    In `BaseControllerTestCase.setUp()`:
    1. Change line 29 from `self.patcher_sonarr = patch('controller.controller.SonarrManager')` to:
       `self.patcher_webhook = patch('controller.controller.WebhookManager')`
       Note: We are NOT patching WebhookManager class creation because Controller no longer creates it
       internally. Instead, Controller receives webhook_manager as a constructor argument. But since the
       current test infrastructure patches at class level, we need to create a mock WebhookManager and
       pass it in. Actually -- WAIT. Controller.__init__ now takes `webhook_manager` as a parameter (it
       no longer creates SonarrManager internally). So the patching approach changes:
       - REMOVE the `self.patcher_sonarr = patch('controller.controller.SonarrManager')` line entirely.
       - REMOVE `self.mock_sonarr_manager_cls = self.patcher_sonarr.start()` line.
       - REMOVE `self.mock_sonarr_manager = self.mock_sonarr_manager_cls.return_value` line.
       - REMOVE `self.mock_sonarr_manager.process.return_value = []` line.
       - ADD: `self.mock_webhook_manager = MagicMock()` (create a plain mock, no patching needed).
       - ADD: `self.mock_webhook_manager.process.return_value = []` (default: no imports).
       - Change Controller instantiation from
         `self.controller = Controller(context=self.mock_context, persist=self.persist)`
         to:
         `self.controller = Controller(context=self.mock_context, persist=self.persist, webhook_manager=self.mock_webhook_manager)`
    2. In `tearDown()`:
       - REMOVE `self.patcher_sonarr.stop()` line.

    In `TestControllerSonarrIntegration` class (line 1030):
    1. Rename class to `TestControllerWebhookIntegration`.
    2. Update `test_process_calls_sonarr_manager` (line 1037):
       - Rename to `test_process_calls_webhook_manager`
       - Change assertion from `self.assertTrue(self.mock_sonarr_manager.process.called)` to
         `self.assertTrue(self.mock_webhook_manager.process.called)`
    3. Update `test_sonarr_imports_added_to_persist` (line 1041):
       - Rename to `test_webhook_imports_added_to_persist`
       - Change `self.mock_sonarr_manager.process.return_value` to `self.mock_webhook_manager.process.return_value`
    4. Update `test_sonarr_disabled_no_imports` (line 1049):
       - Rename to `test_webhook_no_imports_when_empty`
       - Change `self.mock_sonarr_manager.process.return_value` to `self.mock_webhook_manager.process.return_value`

    ---

    **Update `src/python/tests/unittests/test_controller/test_auto_delete.py`:**

    In `BaseAutoDeleteTestCase.setUp()`:
    1. Same changes as BaseControllerTestCase above:
       - REMOVE `self.patcher_sonarr = patch('controller.controller.SonarrManager')` line.
       - REMOVE `self.mock_sonarr_manager_cls = self.patcher_sonarr.start()` line.
       - REMOVE `self.mock_sonarr_manager = self.mock_sonarr_manager_cls.return_value` line.
       - REMOVE `self.mock_sonarr_manager.process.return_value = []` line.
       - ADD: `self.mock_webhook_manager = MagicMock()` (plain mock).
       - ADD: `self.mock_webhook_manager.process.return_value = []` (default: no imports).
       - Change Controller instantiation to pass `webhook_manager=self.mock_webhook_manager`.
    2. In `tearDown()`:
       - REMOVE `self.patcher_sonarr.stop()` line.
    3. In `TestAutoDeleteIntegration`:
       - Rename `test_sonarr_import_triggers_auto_delete_schedule` to
         `test_webhook_import_triggers_auto_delete_schedule`.
       - Change `self.mock_sonarr_manager.process.return_value` to `self.mock_webhook_manager.process.return_value`.
       - Rename `test_sonarr_import_no_schedule_when_disabled` to
         `test_webhook_import_no_schedule_when_disabled`.
       - Change `self.mock_sonarr_manager.process.return_value` to `self.mock_webhook_manager.process.return_value`.
    4. Remove `self.mock_context.config.sonarr.enabled = False` from setUp (line 21) -- not relevant
       to WebhookManager which has no enabled flag.

    ---

    **Create `src/python/tests/unittests/test_controller/test_webhook_manager.py`:**

    Write unit tests for WebhookManager. Test cases:

    ```python
    import unittest
    from unittest.mock import MagicMock

    from controller.webhook_manager import WebhookManager


    class TestWebhookManager(unittest.TestCase):
        """Unit tests for WebhookManager."""

        def setUp(self):
            self.mock_context = MagicMock()
            self.mock_context.logger = MagicMock()
            self.manager = WebhookManager(context=self.mock_context)
            self.model_file_names = {"File.A", "File.B", "File.C"}

        def test_process_empty_queue_returns_empty(self):
            result = self.manager.process(self.model_file_names)
            self.assertEqual([], result)

        def test_enqueue_and_process_matching_file(self):
            self.manager.enqueue_import("Sonarr", "File.A")
            result = self.manager.process(self.model_file_names)
            self.assertEqual(["File.A"], result)

        def test_enqueue_and_process_no_match(self):
            self.manager.enqueue_import("Sonarr", "Unknown.File")
            result = self.manager.process(self.model_file_names)
            self.assertEqual([], result)

        def test_case_insensitive_matching(self):
            self.manager.enqueue_import("Sonarr", "file.a")
            result = self.manager.process(self.model_file_names)
            self.assertEqual(["File.A"], result)

        def test_multiple_enqueues_processed_in_one_call(self):
            self.manager.enqueue_import("Sonarr", "File.A")
            self.manager.enqueue_import("Radarr", "File.B")
            result = self.manager.process(self.model_file_names)
            self.assertIn("File.A", result)
            self.assertIn("File.B", result)
            self.assertEqual(2, len(result))

        def test_queue_drained_after_process(self):
            self.manager.enqueue_import("Sonarr", "File.A")
            self.manager.process(self.model_file_names)
            # Second call should return empty
            result = self.manager.process(self.model_file_names)
            self.assertEqual([], result)

        def test_process_with_empty_model(self):
            self.manager.enqueue_import("Sonarr", "File.A")
            result = self.manager.process(set())
            self.assertEqual([], result)

        def test_enqueue_logs_info(self):
            self.manager.enqueue_import("Sonarr", "File.A")
            self.manager.logger.info.assert_called_with(
                "Sonarr webhook import enqueued: 'File.A'"
            )

        def test_matched_import_logs_info(self):
            self.manager.enqueue_import("Sonarr", "File.A")
            self.manager.process(self.model_file_names)
            self.manager.logger.info.assert_any_call(
                "Sonarr import detected: 'File.A' (matched SeedSync file 'File.A')"
            )

        def test_unmatched_import_logs_debug(self):
            self.manager.enqueue_import("Sonarr", "Unknown.File")
            self.manager.process(self.model_file_names)
            self.manager.logger.debug.assert_any_call(
                "Sonarr webhook file 'Unknown.File' not in SeedSync model"
            )
    ```

    ---

    **Create `src/python/tests/unittests/test_web/test_webhook_handler.py`:**

    Write unit tests for WebhookHandler. Test the title extraction methods and the handler logic.
    Use MagicMock for the WebhookManager dependency and bottle test utilities for request mocking.

    Test cases to implement:

    ```python
    import unittest
    from unittest.mock import MagicMock, patch
    import json

    from web.handler.webhook import WebhookHandler


    class TestWebhookHandlerExtractSonarrTitle(unittest.TestCase):
        """Tests for _extract_sonarr_title static method."""

        def test_extracts_source_path_basename(self):
            body = {"episodeFile": {"sourcePath": "/downloads/Game.of.Thrones.S01E01-GROUP"}}
            result = WebhookHandler._extract_sonarr_title(body)
            self.assertEqual("Game.of.Thrones.S01E01-GROUP", result)

        def test_falls_back_to_release_title(self):
            body = {"release": {"releaseTitle": "Game.of.Thrones.S01E01-GROUP"}}
            result = WebhookHandler._extract_sonarr_title(body)
            self.assertEqual("Game.of.Thrones.S01E01-GROUP", result)

        def test_falls_back_to_series_title(self):
            body = {"series": {"title": "Game of Thrones"}}
            result = WebhookHandler._extract_sonarr_title(body)
            self.assertEqual("Game of Thrones", result)

        def test_prefers_source_path_over_release_title(self):
            body = {
                "episodeFile": {"sourcePath": "/downloads/FromSourcePath"},
                "release": {"releaseTitle": "FromRelease"}
            }
            result = WebhookHandler._extract_sonarr_title(body)
            self.assertEqual("FromSourcePath", result)

        def test_empty_body_returns_empty(self):
            result = WebhookHandler._extract_sonarr_title({})
            self.assertEqual("", result)


    class TestWebhookHandlerExtractRadarrTitle(unittest.TestCase):
        """Tests for _extract_radarr_title static method."""

        def test_extracts_source_path_basename(self):
            body = {"movieFile": {"sourcePath": "/downloads/Inception.2010.1080p-GROUP"}}
            result = WebhookHandler._extract_radarr_title(body)
            self.assertEqual("Inception.2010.1080p-GROUP", result)

        def test_falls_back_to_release_title(self):
            body = {"release": {"releaseTitle": "Inception.2010.1080p-GROUP"}}
            result = WebhookHandler._extract_radarr_title(body)
            self.assertEqual("Inception.2010.1080p-GROUP", result)

        def test_falls_back_to_movie_title(self):
            body = {"movie": {"title": "Inception"}}
            result = WebhookHandler._extract_radarr_title(body)
            self.assertEqual("Inception", result)

        def test_empty_body_returns_empty(self):
            result = WebhookHandler._extract_radarr_title({})
            self.assertEqual("", result)


    class TestWebhookHandlerRoutes(unittest.TestCase):
        """Tests for webhook handler routing and event processing."""

        def setUp(self):
            self.mock_webhook_manager = MagicMock()
            self.handler = WebhookHandler(self.mock_webhook_manager)

        @patch('web.handler.webhook.request')
        def test_sonarr_download_event_enqueues(self, mock_request):
            mock_request.json = {
                "eventType": "Download",
                "episodeFile": {"sourcePath": "/downloads/Test.File-GROUP"}
            }
            response = self.handler._handle_webhook("Sonarr", WebhookHandler._extract_sonarr_title)
            self.assertEqual(200, response.status_code)
            self.mock_webhook_manager.enqueue_import.assert_called_once_with(
                "Sonarr", "Test.File-GROUP"
            )

        @patch('web.handler.webhook.request')
        def test_radarr_download_event_enqueues(self, mock_request):
            mock_request.json = {
                "eventType": "Download",
                "movieFile": {"sourcePath": "/downloads/Movie.2024-GROUP"}
            }
            response = self.handler._handle_webhook("Radarr", WebhookHandler._extract_radarr_title)
            self.assertEqual(200, response.status_code)
            self.mock_webhook_manager.enqueue_import.assert_called_once_with(
                "Radarr", "Movie.2024-GROUP"
            )

        @patch('web.handler.webhook.request')
        def test_test_event_returns_200_test_ok(self, mock_request):
            mock_request.json = {"eventType": "Test"}
            response = self.handler._handle_webhook("Sonarr", WebhookHandler._extract_sonarr_title)
            self.assertEqual(200, response.status_code)
            self.assertIn("Test OK", response.body)
            self.mock_webhook_manager.enqueue_import.assert_not_called()

        @patch('web.handler.webhook.request')
        def test_grab_event_returns_200_ok(self, mock_request):
            mock_request.json = {"eventType": "Grab"}
            response = self.handler._handle_webhook("Sonarr", WebhookHandler._extract_sonarr_title)
            self.assertEqual(200, response.status_code)
            self.mock_webhook_manager.enqueue_import.assert_not_called()

        @patch('web.handler.webhook.request')
        def test_rename_event_returns_200_ok(self, mock_request):
            mock_request.json = {"eventType": "Rename"}
            response = self.handler._handle_webhook("Sonarr", WebhookHandler._extract_sonarr_title)
            self.assertEqual(200, response.status_code)
            self.mock_webhook_manager.enqueue_import.assert_not_called()

        @patch('web.handler.webhook.request')
        def test_empty_body_returns_400(self, mock_request):
            mock_request.json = None
            response = self.handler._handle_webhook("Sonarr", WebhookHandler._extract_sonarr_title)
            self.assertEqual(400, response.status_code)
            self.assertIn("Empty body", response.body)

        @patch('web.handler.webhook.request')
        def test_invalid_json_returns_400(self, mock_request):
            type(mock_request).json = property(lambda self: (_ for _ in ()).throw(ValueError("bad json")))
            response = self.handler._handle_webhook("Sonarr", WebhookHandler._extract_sonarr_title)
            self.assertEqual(400, response.status_code)
            self.assertIn("Invalid JSON", response.body)

        @patch('web.handler.webhook.request')
        def test_download_with_no_title_returns_200_no_enqueue(self, mock_request):
            mock_request.json = {"eventType": "Download"}
            response = self.handler._handle_webhook("Sonarr", WebhookHandler._extract_sonarr_title)
            self.assertEqual(200, response.status_code)
            self.mock_webhook_manager.enqueue_import.assert_not_called()

        def test_add_routes_registers_both_endpoints(self):
            mock_web_app = MagicMock()
            self.handler.add_routes(mock_web_app)
            calls = mock_web_app.add_post_handler.call_args_list
            paths = [c[0][0] for c in calls]
            self.assertIn("/server/webhook/sonarr", paths)
            self.assertIn("/server/webhook/radarr", paths)
    ```

    NOTE on `test_invalid_json_returns_400`: The mock for `request.json` raising an exception can be
    tricky. If the property approach doesn't work cleanly, use a simpler approach: patch the `request`
    object so that accessing `.json` raises an exception, e.g., by setting
    `mock_request.json = property(...)` or by making `type(mock_request).json` a property that raises.
    Test it and adjust if needed -- the key is that `request.json` raising any Exception results in 400.
  </action>
  <verify>
    Run all Python tests:
    `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_controller/test_webhook_manager.py -v`
    `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_web/test_webhook_handler.py -v`
    `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_controller/test_controller_unit.py -v`
    `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_controller/test_auto_delete.py -v`
    All tests must pass (0 failures).

    Verify no remaining SonarrManager references:
    `grep -r "SonarrManager\|sonarr_manager\|patcher_sonarr\|mock_sonarr" /Users/julianamacbook/seedsync/src/python/ --include="*.py" || echo "CLEAN"`
    (Should find NO references.)
  </verify>
  <done>
    All existing Controller and auto-delete tests pass with WebhookManager mocks replacing SonarrManager
    mocks. New WebhookManager tests verify: enqueue/process cycle, case-insensitive matching, queue
    draining, empty model handling, logging. New WebhookHandler tests verify: Download event enqueuing,
    Test event handling, non-Download events ignored, error responses for malformed requests, title
    extraction fallback chains, route registration. Zero SonarrManager references remain in the codebase.
  </done>
</task>

</tasks>

<verification>
1. All Python unit tests pass: `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/ -v`
2. No SonarrManager references in codebase: `grep -r "SonarrManager" /Users/julianamacbook/seedsync/src/python/ --include="*.py"` returns nothing
3. WebhookManager import works: `python -c "from controller import WebhookManager"`
4. sonarr_manager.py deleted: `test ! -f src/python/controller/sonarr_manager.py`
5. test_sonarr_manager.py deleted: `test ! -f src/python/tests/unittests/test_controller/test_sonarr_manager.py`
</verification>

<success_criteria>
- POST /server/webhook/sonarr and /server/webhook/radarr routes registered in WebAppBuilder
- WebhookManager enqueue_import() called from web thread, process() called from controller thread
- Controller.__check_webhook_imports() replaces __check_sonarr_imports() with identical downstream flow
- Shared WebhookManager instance created in seedsync.py, passed to both Controller and WebAppBuilder
- SonarrManager and its tests fully removed
- All existing Python unit tests pass (0 failures)
- New WebhookManager tests: 10+ test cases covering enqueue/process/matching/logging
- New WebhookHandler tests: 10+ test cases covering routing/events/extraction/errors
</success_criteria>

<output>
After completion, create `.planning/phases/27-webhook-import-detection/27-01-SUMMARY.md`
</output>
