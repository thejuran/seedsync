---
phase: 05-booking-impact-booking-windows
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/engine/booking_impact.py
  - backend/engine/booking_windows.py
  - backend/api/reservations.py
  - backend/api/schemas.py
  - backend/main.py
  - tests/test_booking_impact.py
  - tests/test_booking_windows.py
  - tests/test_api_reservations.py
autonomous: true

must_haves:
  truths:
    - "Preview endpoint returns before/after point balances for a proposed booking"
    - "Preview endpoint returns nightly point breakdown"
    - "Preview endpoint returns banking warning when booking consumes bankable points"
    - "Preview endpoint returns booking window open dates (11-month and 7-month)"
    - "Booking window dates handle end-of-month edge cases correctly (DVC roll-forward)"
  artifacts:
    - path: "backend/engine/booking_impact.py"
      provides: "Pure-function booking impact computation"
      exports: ["compute_booking_impact", "compute_banking_warning"]
    - path: "backend/engine/booking_windows.py"
      provides: "Pure-function booking window date calculations"
      exports: ["compute_booking_windows", "_dvc_subtract_months"]
    - path: "backend/api/reservations.py"
      provides: "POST /api/reservations/preview endpoint"
    - path: "backend/api/schemas.py"
      provides: "ReservationPreviewRequest, ReservationPreviewResponse schemas"
    - path: "tests/test_booking_impact.py"
      provides: "Engine unit tests for booking impact"
    - path: "tests/test_booking_windows.py"
      provides: "Engine unit tests for booking window calculations"
  key_links:
    - from: "backend/api/reservations.py"
      to: "backend/engine/booking_impact.py"
      via: "preview endpoint calls compute_booking_impact()"
      pattern: "compute_booking_impact"
    - from: "backend/api/reservations.py"
      to: "backend/engine/booking_windows.py"
      via: "preview endpoint calls compute_booking_windows()"
      pattern: "compute_booking_windows"
    - from: "backend/engine/booking_impact.py"
      to: "backend/engine/availability.py"
      via: "calls get_contract_availability() for before/after diff"
      pattern: "get_contract_availability"
    - from: "backend/engine/booking_impact.py"
      to: "backend/data/point_charts.py"
      via: "calls calculate_stay_cost() for nightly breakdown"
      pattern: "calculate_stay_cost"
---

<objective>
Build the backend engine functions and API endpoint for booking impact preview and booking window calculations.

Purpose: This is the foundation that both the Trip Explorer frontend (Plan 02) and Dashboard alerts (Plan 03) depend on. All computation is pure functions in the engine layer; the API endpoint composes them with DB data loading.

Output: Two new engine modules (booking_impact.py, booking_windows.py), extended reservations API with POST /api/reservations/preview, updated schemas, and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-booking-impact-booking-windows/05-RESEARCH.md
@backend/engine/availability.py
@backend/engine/use_year.py
@backend/data/point_charts.py
@backend/api/reservations.py
@backend/api/schemas.py
@backend/api/availability.py
@backend/main.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Booking windows engine + booking impact engine with tests</name>
  <files>
    backend/engine/booking_windows.py
    backend/engine/booking_impact.py
    tests/test_booking_windows.py
    tests/test_booking_impact.py
  </files>
  <action>
Create two new pure-function engine modules:

**backend/engine/booking_windows.py:**
- `_dvc_subtract_months(check_in: date, months: int) -> date` -- Subtract months with DVC end-of-month correction. When `relativedelta` clips the day (naive.day < check_in.day), roll forward to 1st of next month instead of clipping backward. Use `dateutil.relativedelta` (already in requirements.txt).
- `compute_booking_windows(check_in: date, is_home_resort: bool) -> dict` -- Returns dict with: `home_resort_window` (ISO date string), `home_resort_window_open` (bool), `days_until_home_window` (int, negative if past), `any_resort_window` (ISO date string), `any_resort_window_open` (bool), `days_until_any_window` (int, negative if past), `is_home_resort` (bool). Home window = 11 months before check_in. Any-resort window = 7 months before check_in. Use `date.today()` for comparison.

**backend/engine/booking_impact.py:**
- `compute_booking_impact(contract: dict, point_balances: list[dict], reservations: list[dict], proposed_resort: str, proposed_room_key: str, proposed_check_in: date, proposed_check_out: date) -> dict` -- Compute before/after availability diff. Call `get_contract_availability()` from `backend.engine.availability` with only this contract's balances/reservations for "before". Call `calculate_stay_cost()` from `backend.data.point_charts` for nightly breakdown. Build a synthetic reservation dict `{"check_in": proposed_check_in, "points_cost": stay_cost["total_points"], "status": "confirmed", "contract_id": contract["id"]}`, append to this contract's reservations, call `get_contract_availability()` again for "after". Return dict with keys: `before` (availability dict), `after` (availability dict), `stay_cost` (full stay cost result with nightly_breakdown), `points_delta` (int, total points cost). If `calculate_stay_cost` returns None, return `{"error": "Could not calculate stay cost -- point chart data not available for these dates"}`.
- `compute_banking_warning(contract: dict, before_availability: dict, points_cost: int) -> dict | None` -- Conservative banking warning. Returns None if banking deadline has already passed (`before_availability["banking_deadline_passed"]` is True). Returns None if no current-year points in balances (`before_availability["balances"].get("current", 0)` is 0). Otherwise, compute `bankable = before_availability["balances"].get("current", 0)` (current allocation points that could theoretically be banked). If `points_cost > (before_availability["available_points"] - bankable)` -- meaning the booking MUST dip into current-year points -- return warning dict with: `warning: True`, `bankable_points: bankable`, `banking_deadline: before_availability["banking_deadline"]`, `days_until_deadline: before_availability["days_until_banking_deadline"]`, `message: str` (human-readable). Otherwise return None.

**tests/test_booking_windows.py:**
Test `_dvc_subtract_months` edge cases:
- Standard case: March 15 - 11 months = April 15 prior year
- Standard case: March 15 - 7 months = August 15 prior year
- End-of-month: Sept 30 - 7 months = March 1 (NOT Feb 28) in non-leap year
- End-of-month: Sept 29 - 7 months = March 1 in non-leap year (2026)
- Leap year: Sept 29 - 7 months = Feb 29 in leap year (2028)
- No clipping: Oct 31 - 7 months = March 31
- Year boundary: Jan 31 - 11 months = March 1 prior year
Test `compute_booking_windows` with a known check_in date, verify all fields present.

**tests/test_booking_impact.py:**
Test `compute_booking_impact` with a mock contract (id=1, use_year_month=2, annual_points=200), point balance (use_year=2026, allocation_type="current", points=200), no existing reservations. Use a resort/room that exists in the test point chart data (check conftest.py for fixtures or use polynesian/deluxe_studio for a date in 2026 that has chart data). Verify before.available_points > after.available_points, verify points_delta matches stay_cost total. Test `compute_banking_warning`: verify warning fires when banking deadline not passed and cost exceeds non-current balance; verify no warning when deadline passed.
  </action>
  <verify>
Run: `cd /Users/julianamacbook/DVC && python -m pytest tests/test_booking_windows.py tests/test_booking_impact.py -v`
All tests pass. At minimum 7 booking window tests and 3 booking impact tests.
  </verify>
  <done>
Both engine modules exist with pure functions. All tests pass. `_dvc_subtract_months` correctly handles end-of-month edge cases. `compute_booking_impact` returns before/after availability diffs. `compute_banking_warning` fires conservatively when bankable points would be consumed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Preview API endpoint with schemas and integration tests</name>
  <files>
    backend/api/schemas.py
    backend/api/reservations.py
    backend/main.py
    tests/test_api_reservations.py
  </files>
  <action>
**backend/api/schemas.py -- add these new schemas:**
- `ReservationPreviewRequest(BaseModel)`: `contract_id: int`, `resort: str`, `room_key: str`, `check_in: date_type`, `check_out: date_type`. Add same `check_out > check_in` validator as ReservationCreate.
- `BookingWindowInfo(BaseModel)`: `home_resort_window: str`, `home_resort_window_open: bool`, `days_until_home_window: int`, `any_resort_window: str`, `any_resort_window_open: bool`, `days_until_any_window: int`, `is_home_resort: bool`.
- `BankingWarning(BaseModel)`: `warning: bool`, `bankable_points: int`, `banking_deadline: str`, `days_until_deadline: int`, `message: str`.
- `AvailabilitySnapshot(BaseModel)`: `total_points: int`, `committed_points: int`, `available_points: int`, `balances: dict`.
- `ReservationPreviewResponse(BaseModel)`: `before: AvailabilitySnapshot`, `after: AvailabilitySnapshot`, `points_delta: int`, `nightly_breakdown: list[NightlyCost]` (reuse existing), `total_points: int`, `num_nights: int`, `booking_windows: BookingWindowInfo`, `banking_warning: BankingWarning | None`.

**backend/api/reservations.py -- add preview endpoint:**
Add `POST /api/reservations/preview` to the existing router. Import `compute_booking_impact`, `compute_banking_warning` from `backend.engine.booking_impact` and `compute_booking_windows` from `backend.engine.booking_windows`. Import `ReservationPreviewRequest` and `ReservationPreviewResponse` from schemas. Import Contract, PointBalance, Reservation, AppSetting models and get_db.

Endpoint logic:
1. Load the contract by `data.contract_id` -- 404 if not found.
2. Load all point balances for this contract (`PointBalance.contract_id == data.contract_id`).
3. Load all non-cancelled reservations for this contract.
4. Convert ORM objects to dicts (same pattern as `backend/api/availability.py`).
5. Build contract dict with id, use_year_month, annual_points, home_resort.
6. Call `compute_booking_impact(contract_dict, balances_data, reservations_data, data.resort, data.room_key, data.check_in, data.check_out)`.
7. If result has "error" key, raise HTTPException 422 with the error message.
8. Call `compute_banking_warning(contract_dict, result["before"], result["stay_cost"]["total_points"])`.
9. Determine `is_home_resort = (contract.home_resort == data.resort)`.
10. Call `compute_booking_windows(data.check_in, is_home_resort)`.
11. Return ReservationPreviewResponse assembling all pieces.

Place the preview route BEFORE the `/{reservation_id}` routes so it doesn't get captured as a path parameter.

**backend/main.py:** No changes needed -- reservations_router is already registered.

**tests/test_api_reservations.py -- add preview endpoint tests:**
Add tests using the existing test client fixture (check conftest.py for async test client pattern). Test:
- POST /api/reservations/preview with valid contract_id, resort, room_key, check_in, check_out returns 200 with before/after/booking_windows.
- POST /api/reservations/preview with invalid contract_id returns 404.
- POST /api/reservations/preview with resort that has no point chart returns 422.
- Verify response includes nightly_breakdown with correct number of nights.
- Verify booking_windows has all expected fields.
  </action>
  <verify>
Run: `cd /Users/julianamacbook/DVC && python -m pytest tests/test_api_reservations.py -v`
All existing + new tests pass. Preview endpoint returns correct schema.
Also verify manually: `cd /Users/julianamacbook/DVC && python -c "from backend.api.schemas import ReservationPreviewResponse; print('Schema OK')"` -- no import errors.
  </verify>
  <done>
POST /api/reservations/preview endpoint works. Returns before/after availability snapshots, nightly breakdown, booking window dates, and banking warning (when applicable). All reservation API tests pass including new preview tests.
  </done>
</task>

</tasks>

<verification>
1. All existing tests still pass: `python -m pytest tests/ -v --tb=short`
2. Preview endpoint accessible: `curl -X POST http://localhost:8000/api/reservations/preview -H 'Content-Type: application/json' -d '{"contract_id": 1, "resort": "polynesian", "room_key": "deluxe_studio", "check_in": "2026-06-15", "check_out": "2026-06-18"}'` returns 200 with complete response
3. Engine functions are pure (no DB imports in booking_impact.py or booking_windows.py)
4. Booking window edge cases tested (Sept 30, Sept 29, Oct 31, Jan 31)
</verification>

<success_criteria>
- POST /api/reservations/preview returns before/after point balances, nightly breakdown, booking windows, and banking warning
- All 7+ booking window edge case tests pass
- All 3+ booking impact tests pass
- All preview API integration tests pass
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/05-booking-impact-booking-windows/05-01-SUMMARY.md`
</output>
