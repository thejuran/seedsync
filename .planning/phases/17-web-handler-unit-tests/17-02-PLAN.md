---
phase: 17-web-handler-unit-tests
plan: 02
type: execute
wave: 1
depends_on: ["15-01"]
files_modified:
  - src/python/tests/unittests/test_web/test_handler/test_stream_heartbeat.py
  - src/python/tests/unittests/test_web/test_handler/test_stream_model_handler.py
  - src/python/tests/unittests/test_web/test_handler/test_stream_status_handler.py
autonomous: true

must_haves:
  truths:
    - "HeartbeatStreamHandler sends initial heartbeat immediately on first get_value() after setup()"
    - "HeartbeatStreamHandler returns None when HEARTBEAT_INTERVAL_S has not elapsed"
    - "HeartbeatStreamHandler returns SSE ping event with correct format after interval elapses"
    - "ModelStreamHandler setup registers listener via controller.get_model_files_and_add_listener()"
    - "ModelStreamHandler delivers initial files one at a time as ADDED events before processing queue"
    - "ModelStreamHandler cleanup removes listener via controller.remove_model_listener()"
    - "StatusStreamHandler first get_value() returns serialized copy of current status"
    - "StatusStreamHandler subsequent get_value() reads from listener queue"
    - "StatusStreamHandler cleanup removes listener via status.remove_listener()"
    - "All 721+ existing tests still pass with zero regressions"
  artifacts:
    - path: "src/python/tests/unittests/test_web/test_handler/test_stream_heartbeat.py"
      provides: "Unit tests for HeartbeatStreamHandler lifecycle and timing"
      contains: "class TestHeartbeatStreamHandler"
    - path: "src/python/tests/unittests/test_web/test_handler/test_stream_model_handler.py"
      provides: "Unit tests for ModelStreamHandler and WebResponseModelListener"
      contains: "class TestModelStreamHandler"
    - path: "src/python/tests/unittests/test_web/test_handler/test_stream_status_handler.py"
      provides: "Unit tests for StatusStreamHandler and StatusListener"
      contains: "class TestStatusStreamHandler"
  key_links:
    - from: "src/python/tests/unittests/test_web/test_handler/test_stream_heartbeat.py"
      to: "web.handler.stream_heartbeat.HeartbeatStreamHandler"
      via: "from web.handler.stream_heartbeat import HeartbeatStreamHandler"
      pattern: "@patch.*web.handler.stream_heartbeat.time"
    - from: "src/python/tests/unittests/test_web/test_handler/test_stream_model_handler.py"
      to: "web.handler.stream_model.ModelStreamHandler"
      via: "from web.handler.stream_model import ModelStreamHandler, WebResponseModelListener"
      pattern: "controller.get_model_files_and_add_listener"
    - from: "src/python/tests/unittests/test_web/test_handler/test_stream_status_handler.py"
      to: "web.handler.stream_status.StatusStreamHandler"
      via: "from web.handler.stream_status import StatusStreamHandler, StatusListener"
      pattern: "status.add_listener"
---

<objective>
Create unit tests for the 3 streaming web handlers: HeartbeatStreamHandler, ModelStreamHandler, and StatusStreamHandler.

Purpose: These handlers implement IStreamHandler with setup()/get_value()/cleanup() lifecycle methods. Integration tests for all 3 are @unittest.skip-ed because webtest cannot handle SSE streaming, making unit tests the ONLY viable test path. HeartbeatStreamHandler is completely untested anywhere in the codebase. Testing the IStreamHandler lifecycle directly verifies heartbeat timing, model event delivery, and status streaming without involving the WebApp streaming loop.

Output: 3 new test files in src/python/tests/unittests/test_web/test_handler/ adding ~30 test methods covering all stream handler lifecycle methods, inner listener classes, and edge cases.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v1.5-ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-web-handler-unit-tests/17-RESEARCH.md
@.planning/phases/15-coverage-tooling-shared-fixtures/15-01-SUMMARY.md
@src/python/web/handler/stream_heartbeat.py
@src/python/web/handler/stream_model.py
@src/python/web/handler/stream_status.py
@src/python/web/web_app.py
@src/python/web/utils.py
@src/python/web/serialize/serialize.py
@src/python/web/serialize/serialize_model.py
@src/python/web/serialize/serialize_status.py
@src/python/tests/unittests/test_web/test_handler/test_stream_log.py
@src/python/tests/unittests/test_web/test_handler/test_controller_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_stream_heartbeat.py and test_stream_model_handler.py</name>
  <files>
    src/python/tests/unittests/test_web/test_handler/test_stream_heartbeat.py
    src/python/tests/unittests/test_web/test_handler/test_stream_model_handler.py
  </files>
  <action>
  Create two test files for the heartbeat and model stream handlers. Follow the test_stream_log.py pattern for time.time() mocking. Test IStreamHandler lifecycle methods directly: setup() then get_value() then cleanup().

  **A. Create test_stream_heartbeat.py:**

  Copyright header: `# Copyright 2017, Inderpreet Singh, All rights reserved.`

  Imports:
  ```python
  import unittest
  from unittest.mock import patch

  from web.handler.stream_heartbeat import HeartbeatStreamHandler, SerializeHeartbeat
  ```

  Class `TestSerializeHeartbeat(unittest.TestCase)`:
  - `test_ping_returns_sse_format`: Create `s = SerializeHeartbeat()`. Call `result = s.ping(1000.0)`. assertIn("event: ping", result). assertIn("data: 1000.0", result). assertTrue(result.endswith("\n\n")).
  - `test_ping_contains_timestamp`: Call `s.ping(1234567890.5)`. assertIn("1234567890.5", result).

  Class `TestHeartbeatStreamHandler(unittest.TestCase)`:

  All test methods in this class must use `@patch("web.handler.stream_heartbeat.time")` to mock the time module. This is the same pattern as test_stream_log.py uses `@patch("web.handler.stream_log.time")`. The mock replaces the `time` module imported at the top of stream_heartbeat.py, so `mock_time_module.time.return_value` controls what `time.time()` returns.

  - `test_setup_resets_state`: Patch time. `mock_time_module.time.return_value = 1000.0`. Create handler. Call `handler.setup()`. Then call `handler.get_value()` -- should return a ping (because _last_heartbeat_time is None after setup). assertIsNotNone(result).

  - `test_initial_heartbeat_sent_immediately`: Patch time. `mock_time_module.time.return_value = 1000.0`. Create handler. `handler.setup()`. `result = handler.get_value()`. assertIsNotNone(result). assertIn("event: ping", result). assertIn("1000.0", result).

  - `test_no_heartbeat_before_interval`: Patch time. `mock_time_module.time.return_value = 1000.0`. Create handler. `handler.setup()`. `handler.get_value()` (consume initial). `mock_time_module.time.return_value = 1005.0` (only 5 seconds, interval is 15). `result = handler.get_value()`. assertIsNone(result).

  - `test_heartbeat_after_interval`: Patch time. `mock_time_module.time.return_value = 1000.0`. Create handler. `handler.setup()`. `handler.get_value()` (consume initial). `mock_time_module.time.return_value = 1015.0` (exactly 15 seconds). `result = handler.get_value()`. assertIsNotNone(result). assertIn("event: ping", result). assertIn("1015.0", result).

  - `test_heartbeat_after_interval_exceeded`: Patch time. `mock_time_module.time.return_value = 1000.0`. Create handler. `handler.setup()`. `handler.get_value()`. `mock_time_module.time.return_value = 1020.0` (20 seconds, > interval). `result = handler.get_value()`. assertIsNotNone(result).

  - `test_multiple_heartbeat_cycles`: Patch time. Start at 1000.0. setup, get_value (initial). Advance to 1015.0, get_value (second heartbeat). Advance to 1025.0, get_value -- assertIsNone (only 10s since last). Advance to 1030.0, get_value (third heartbeat, 15s since 1015.0). assertIsNotNone. This verifies the interval resets after each heartbeat.

  - `test_cleanup_is_noop`: Patch time. `mock_time_module.time.return_value = 1000.0`. Create handler. `handler.setup()`. `handler.cleanup()` -- should not raise any exception.

  - `test_heartbeat_interval_constant`: assertEqual(15, HeartbeatStreamHandler.HEARTBEAT_INTERVAL_S).

  - `test_setup_can_be_called_again`: Patch time. Create handler. `mock_time_module.time.return_value = 1000.0`. `handler.setup()`. `handler.get_value()` (consume initial at 1000.0). `mock_time_module.time.return_value = 1005.0`. result = `handler.get_value()`. assertIsNone(result) (5s < interval). Now call `handler.setup()` again to reset. `mock_time_module.time.return_value = 1006.0`. result = `handler.get_value()`. assertIsNotNone(result) (initial heartbeat again because setup reset _last_heartbeat_time to None).

  **B. Create test_stream_model_handler.py:**

  Copyright header: `# Copyright 2017, Inderpreet Singh, All rights reserved.`

  Imports:
  ```python
  import unittest
  from unittest.mock import MagicMock

  from controller import Controller
  from model import ModelFile
  from web.handler.stream_model import ModelStreamHandler, WebResponseModelListener
  from web.serialize import SerializeModel
  ```

  Class `TestWebResponseModelListener(unittest.TestCase)`:
  Test the inner listener class that bridges IModelListener events to the StreamQueue.

  - `test_file_added_puts_added_event`: Create `listener = WebResponseModelListener()`. Create `file = ModelFile("test.txt", False)`. Call `listener.file_added(file)`. Call `event = listener.get_next_event()`. assertIsNotNone(event). assertEqual(SerializeModel.UpdateEvent.Change.ADDED, event.change). assertIsNone(event.old_file). assertIs(file, event.new_file).
  - `test_file_removed_puts_removed_event`: Create listener. Create file. Call `listener.file_removed(file)`. Get event. assertEqual(SerializeModel.UpdateEvent.Change.REMOVED, event.change). assertIs(file, event.old_file). assertIsNone(event.new_file).
  - `test_file_updated_puts_updated_event`: Create listener. Create `old_file = ModelFile("test.txt", False)` and `new_file = ModelFile("test.txt", False)`. Call `listener.file_updated(old_file, new_file)`. Get event. assertEqual(SerializeModel.UpdateEvent.Change.UPDATED, event.change). assertIs(old_file, event.old_file). assertIs(new_file, event.new_file).
  - `test_empty_queue_returns_none`: Create listener (no events put). `event = listener.get_next_event()`. assertIsNone(event).

  Class `TestModelStreamHandler(unittest.TestCase)`:
  - `setUp`: Create `self.mock_controller = MagicMock(spec=Controller)`. Create `self.handler = ModelStreamHandler(self.mock_controller)`.

  - `test_setup_registers_listener`: Set `self.mock_controller.get_model_files_and_add_listener.return_value = []`. Call `self.handler.setup()`. `self.mock_controller.get_model_files_and_add_listener.assert_called_once()`. Verify the argument is the handler's model_listener: `call_args = self.mock_controller.get_model_files_and_add_listener.call_args[0][0]`. assertIs(call_args, self.handler.model_listener).

  - `test_initial_files_sent_one_at_a_time`: Create `file1 = ModelFile("alpha.txt", False)` and `file2 = ModelFile("beta.txt", False)`. Set `self.mock_controller.get_model_files_and_add_listener.return_value = [file1, file2]`. `self.handler.setup()`. First `result1 = self.handler.get_value()`. assertIsNotNone(result1). assertIn("model-added", result1). Second `result2 = self.handler.get_value()`. assertIsNotNone(result2). assertIn("model-added", result2). Third `result3 = self.handler.get_value()`. assertIsNone(result3) -- no more initial files and empty queue.

  - `test_empty_initial_model`: Set return_value = []. `self.handler.setup()`. `result = self.handler.get_value()`. assertIsNone(result).

  - `test_initial_files_contain_file_data`: Create `file = ModelFile("test.txt", False)`. Set return_value = [file]. `self.handler.setup()`. `result = self.handler.get_value()`. assertIn("test.txt", result) -- the serialized event should contain the file name.

  - `test_realtime_events_after_initial_files`: Set return_value = []. `self.handler.setup()`. Simulate a real-time event: `new_file = ModelFile("new.txt", False)`. `self.handler.model_listener.file_added(new_file)`. `result = self.handler.get_value()`. assertIsNotNone(result). assertIn("model-added", result). assertIn("new.txt", result).

  - `test_realtime_removed_event`: Set return_value = []. `self.handler.setup()`. `old_file = ModelFile("removed.txt", False)`. `self.handler.model_listener.file_removed(old_file)`. `result = self.handler.get_value()`. assertIn("model-removed", result).

  - `test_realtime_updated_event`: Set return_value = []. `self.handler.setup()`. Create old and new ModelFile. `self.handler.model_listener.file_updated(old_file, new_file)`. `result = self.handler.get_value()`. assertIn("model-updated", result).

  - `test_no_events_returns_none`: Set return_value = []. `self.handler.setup()`. `result = self.handler.get_value()`. assertIsNone(result).

  - `test_cleanup_removes_listener`: Set return_value = []. `self.handler.setup()`. `self.handler.cleanup()`. `self.mock_controller.remove_model_listener.assert_called_once_with(self.handler.model_listener)`.

  - `test_cleanup_with_no_setup`: The handler initializes model_listener in __init__, so cleanup should still work. `self.handler.cleanup()`. `self.mock_controller.remove_model_listener.assert_called_once()`.

  - `test_mixed_initial_and_realtime`: Set return_value = [ModelFile("init.txt", False)]. `self.handler.setup()`. Add a realtime event BEFORE consuming initial: `self.handler.model_listener.file_added(ModelFile("realtime.txt", False))`. First get_value returns initial file (assertIn "init.txt"). Second get_value returns realtime event (assertIn "realtime.txt"). Third get_value returns None.
  </action>
  <verify>
  Run from src/python/:
  - `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_web/test_handler/test_stream_heartbeat.py tests/unittests/test_web/test_handler/test_stream_model_handler.py -v`
  All tests must pass. Expected: ~23 test methods, 0 failures.
  </verify>
  <done>
  test_stream_heartbeat.py has TestSerializeHeartbeat (2 methods) and TestHeartbeatStreamHandler (8 methods) covering: SSE format, initial heartbeat immediate, no heartbeat before interval, heartbeat after interval (exact and exceeded), multiple cycles, cleanup noop, interval constant, setup reset.
  test_stream_model_handler.py has TestWebResponseModelListener (4 methods) and TestModelStreamHandler (9 methods) covering: listener file_added/removed/updated events, empty queue, setup registers listener, initial files one-at-a-time, empty initial model, realtime events (added/removed/updated), cleanup removes listener, mixed initial and realtime delivery order.
  All tests pass with correct time.time() mocking.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test_stream_status_handler.py, run full regression</name>
  <files>
    src/python/tests/unittests/test_web/test_handler/test_stream_status_handler.py
  </files>
  <action>
  Create the final stream handler test file and run full regression across all 7 new test files and the entire suite.

  **A. Create test_stream_status_handler.py:**

  Copyright header: `# Copyright 2017, Inderpreet Singh, All rights reserved.`

  Imports:
  ```python
  import unittest
  from unittest.mock import MagicMock, call

  from web.handler.stream_status import StatusStreamHandler, StatusListener
  ```

  Class `TestStatusListener(unittest.TestCase)`:
  Test the inner StatusListener class that bridges IStatusListener.notify() to the StreamQueue.

  - `test_notify_copies_status_and_queues`: Create `mock_status = MagicMock()`. Create `mock_copy = MagicMock()`. `mock_status.copy.return_value = mock_copy`. Create `listener = StatusListener(mock_status)`. Call `listener.notify()`. `mock_status.copy.assert_called_once()`. `event = listener.get_next_event()`. assertIs(mock_copy, event).
  - `test_multiple_notifications_queued`: Create mock_status. `mock_status.copy.side_effect = [MagicMock(), MagicMock()]` (two different copy results). Create listener. `listener.notify()`. `listener.notify()`. `event1 = listener.get_next_event()`. `event2 = listener.get_next_event()`. assertIsNotNone(event1). assertIsNotNone(event2). assertIsNot(event1, event2).
  - `test_empty_queue_returns_none`: Create mock_status. Create listener (no notify calls). `event = listener.get_next_event()`. assertIsNone(event).

  Class `TestStatusStreamHandler(unittest.TestCase)`:
  - `setUp`: Create `self.mock_status = MagicMock()`. Create `self.handler = StatusStreamHandler(self.mock_status)`.
    IMPORTANT: The real SerializeStatus created in __init__ cannot serialize MagicMock objects
    (json.dumps raises TypeError). Replace the serializer with a mock after construction:
    `self.handler.serialize = MagicMock()` and
    `self.handler.serialize.status.return_value = "event: status\ndata: {}\n\n"`.

  - `test_setup_registers_listener`: `self.handler.setup()`. `self.mock_status.add_listener.assert_called_once_with(self.handler.status_listener)`.

  - `test_first_get_value_returns_current_status`: Create `mock_status_copy = MagicMock()`. Set `self.mock_status.copy.return_value = mock_status_copy`. `self.handler.setup()`. `result = self.handler.get_value()`. assertIsNotNone(result). `self.mock_status.copy.assert_called_once()`. The result should be an SSE-formatted string containing "event: status".  assertIn("event: status", result).

  - `test_first_get_value_sets_first_run_false`: `self.mock_status.copy.return_value = MagicMock()`. `self.handler.setup()`. assertTrue(self.handler.first_run). `self.handler.get_value()`. assertFalse(self.handler.first_run).

  - `test_second_get_value_reads_from_queue`: `self.mock_status.copy.return_value = MagicMock()`. `self.handler.setup()`. `self.handler.get_value()` (consume first run). Now with empty queue: `result = self.handler.get_value()`. assertIsNone(result).

  - `test_second_get_value_returns_queued_status`: `self.mock_status.copy.return_value = MagicMock()`. `self.handler.setup()`. `self.handler.get_value()` (consume first run). Simulate a status update via the listener: `queued_status = MagicMock()`. `self.mock_status.copy.return_value = queued_status`. `self.handler.status_listener.notify()`. `result = self.handler.get_value()`. assertIsNotNone(result). assertIn("event: status", result).

  - `test_cleanup_removes_listener`: `self.handler.setup()`. `self.handler.cleanup()`. `self.mock_status.remove_listener.assert_called_once_with(self.handler.status_listener)`.

  - `test_cleanup_with_no_setup`: Handler initializes status_listener in __init__. `self.handler.cleanup()`. `self.mock_status.remove_listener.assert_called_once()`.

  **B. Run full regression across all 7 new files:**
  After creating the file, run all 7 new test files together, then run the full suite.
  </action>
  <verify>
  Run from src/python/:

  1. Run only test_stream_status_handler.py:
  `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_web/test_handler/test_stream_status_handler.py -v`
  All tests must pass. Expected: ~10 test methods, 0 failures.

  2. Run ALL 7 new files from both plans together:
  `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_web/test_handler/test_auto_queue_handler.py tests/unittests/test_web/test_handler/test_config_handler.py tests/unittests/test_web/test_handler/test_server_handler.py tests/unittests/test_web/test_handler/test_status_handler.py tests/unittests/test_web/test_handler/test_stream_heartbeat.py tests/unittests/test_web/test_handler/test_stream_model_handler.py tests/unittests/test_web/test_handler/test_stream_status_handler.py -v`
  Expected: ~60 test methods total across all 7 files, all passing.

  3. Run ALL tests to confirm zero regressions:
  `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest -q 2>&1 | tail -5`
  Must show 721+ tests with no NEW failures.
  </verify>
  <done>
  test_stream_status_handler.py has TestStatusListener (3 methods) and TestStatusStreamHandler (6 methods) covering: listener notify copies and queues status, multiple notifications, empty queue, setup registers listener, first get_value returns serialized status copy, first_run flag, second get_value reads from queue, cleanup removes listener.
  All 7 new test files (from both Plan 1 and Plan 2) pass together (~60 tests total).
  All 721+ existing tests still pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
Phase-level verification after both tasks complete:

1. **All 3 stream handler test files exist:**
   `ls src/python/tests/unittests/test_web/test_handler/test_stream_heartbeat.py src/python/tests/unittests/test_web/test_handler/test_stream_model_handler.py src/python/tests/unittests/test_web/test_handler/test_stream_status_handler.py`

2. **New tests pass in isolation:**
   `cd src/python && poetry run pytest tests/unittests/test_web/test_handler/test_stream_heartbeat.py tests/unittests/test_web/test_handler/test_stream_model_handler.py tests/unittests/test_web/test_handler/test_stream_status_handler.py -v`
   Expected: ~30 tests, all passing.

3. **HeartbeatStreamHandler (previously ZERO coverage) now tested:**
   Tests cover initial heartbeat, interval enforcement, multiple cycles, setup reset, cleanup, SSE format.

4. **Stream handler integration test gap closed:**
   All 3 stream handlers that had @unittest.skip-ed integration tests now have unit test coverage via direct IStreamHandler lifecycle method testing.

5. **Zero regressions in full suite:**
   `cd src/python && poetry run pytest -q`
   Expected: 721+ tests total, same pre-existing failure count.

6. **Copyright headers present:**
   Each file starts with `# Copyright 2017, Inderpreet Singh, All rights reserved.`

7. **Pattern compliance:**
   - time.time() mocked via `@patch("web.handler.stream_heartbeat.time")` (same pattern as test_stream_log.py)
   - IStreamHandler tested via setup()/get_value()/cleanup() lifecycle
   - Inner classes (WebResponseModelListener, StatusListener) tested directly
   - MagicMock(spec=Controller) for ModelStreamHandler, plain MagicMock for Status
</verification>

<success_criteria>
- 3 new stream handler test files exist in src/python/tests/unittests/test_web/test_handler/
- ~30 test methods across ~5 test classes covering all IStreamHandler lifecycle methods
- HeartbeatStreamHandler: SSE format, initial heartbeat, interval enforcement (before/at/after), multiple cycles, setup reset, cleanup noop, constant value
- ModelStreamHandler: listener events (added/removed/updated), setup registers listener, initial files one-at-a-time, empty initial model, realtime events, no events returns None, cleanup removes listener, mixed initial and realtime
- StatusStreamHandler: listener notify/queue, setup registers listener, first get_value returns status copy, first_run flag, subsequent reads from queue, cleanup removes listener
- time.time() properly mocked (no real delays, no flaky tests)
- All new tests pass
- All 721+ existing tests still pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/17-web-handler-unit-tests/17-02-SUMMARY.md`

The SUMMARY must include:
- Exact count of new test methods added
- Exact count of test classes
- Full test suite pass/fail counts (showing zero new regressions)
- Coverage of previously-untested HeartbeatStreamHandler specifically
- Any deviations from plan
</output>
