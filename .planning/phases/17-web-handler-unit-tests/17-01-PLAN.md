---
phase: 17-web-handler-unit-tests
plan: 01
type: execute
wave: 1
depends_on: ["15-01"]
files_modified:
  - src/python/tests/unittests/test_web/test_handler/test_auto_queue_handler.py
  - src/python/tests/unittests/test_web/test_handler/test_config_handler.py
  - src/python/tests/unittests/test_web/test_handler/test_server_handler.py
  - src/python/tests/unittests/test_web/test_handler/test_status_handler.py
autonomous: true

must_haves:
  truths:
    - "AutoQueueHandler GET/ADD/REMOVE paths are tested with all success and error status codes (200, 400, 404, 409)"
    - "ConfigHandler GET/SET paths are tested including missing section (404), missing key (404), and ConfigError (400)"
    - "ServerHandler restart lifecycle is tested: initial false, after request true, idempotent on repeat"
    - "StatusHandler GET path returns serialized status as HTTPResponse"
    - "URL double-encoding/decoding behavior is tested for AutoQueue and Config handlers"
    - "All 721+ existing tests still pass with zero regressions"
  artifacts:
    - path: "src/python/tests/unittests/test_web/test_handler/test_auto_queue_handler.py"
      provides: "Unit tests for AutoQueueHandler GET/ADD/REMOVE routes"
      contains: "class TestAutoQueueHandler"
    - path: "src/python/tests/unittests/test_web/test_handler/test_config_handler.py"
      provides: "Unit tests for ConfigHandler GET/SET routes"
      contains: "class TestConfigHandler"
    - path: "src/python/tests/unittests/test_web/test_handler/test_server_handler.py"
      provides: "Unit tests for ServerHandler restart lifecycle"
      contains: "class TestServerHandler"
    - path: "src/python/tests/unittests/test_web/test_handler/test_status_handler.py"
      provides: "Unit tests for StatusHandler GET route"
      contains: "class TestStatusHandler"
  key_links:
    - from: "src/python/tests/unittests/test_web/test_handler/test_auto_queue_handler.py"
      to: "web.handler.auto_queue.AutoQueueHandler"
      via: "from web.handler.auto_queue import AutoQueueHandler"
      pattern: "handler._AutoQueueHandler__handle"
    - from: "src/python/tests/unittests/test_web/test_handler/test_config_handler.py"
      to: "web.handler.config.ConfigHandler"
      via: "from web.handler.config import ConfigHandler"
      pattern: "handler._ConfigHandler__handle"
    - from: "src/python/tests/unittests/test_web/test_handler/test_server_handler.py"
      to: "web.handler.server.ServerHandler"
      via: "from web.handler.server import ServerHandler"
      pattern: "handler._ServerHandler__handle_action_restart"
    - from: "src/python/tests/unittests/test_web/test_handler/test_status_handler.py"
      to: "web.handler.status.StatusHandler"
      via: "from web.handler.status import StatusHandler"
      pattern: "handler._StatusHandler__handle_get_status"
---

<objective>
Create unit tests for the 4 request/response web handlers: AutoQueueHandler, ConfigHandler, ServerHandler, and StatusHandler.

Purpose: These handlers implement IHandler and return HTTPResponse objects. They are the simpler half of the 7 untested handlers. Testing them directly (not through TestApp) with mocked dependencies verifies all route logic, error handling, and status codes in isolation.

Output: 4 new test files in src/python/tests/unittests/test_web/test_handler/ adding ~30 test methods covering all handler routes, success paths, error paths, and edge cases.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v1.5-ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-web-handler-unit-tests/17-RESEARCH.md
@.planning/phases/15-coverage-tooling-shared-fixtures/15-01-SUMMARY.md
@src/python/web/handler/auto_queue.py
@src/python/web/handler/config.py
@src/python/web/handler/server.py
@src/python/web/handler/status.py
@src/python/tests/unittests/test_web/test_handler/test_controller_handler.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_auto_queue_handler.py and test_config_handler.py</name>
  <files>
    src/python/tests/unittests/test_web/test_handler/test_auto_queue_handler.py
    src/python/tests/unittests/test_web/test_handler/test_config_handler.py
  </files>
  <action>
  Create two test files for the handlers with the most routes and error paths. Follow the test_controller_handler.py pattern exactly: unittest.TestCase, MagicMock dependencies in setUp(), call private methods via name mangling, assert on HTTPResponse.status_code (int) and HTTPResponse.body (string).

  **A. Create test_auto_queue_handler.py:**

  Copyright header: `# Copyright 2017, Inderpreet Singh, All rights reserved.`

  Imports:
  ```python
  import unittest
  import json
  from unittest.mock import MagicMock
  from urllib.parse import quote

  from controller import AutoQueuePersist, AutoQueuePattern
  from web.handler.auto_queue import AutoQueueHandler
  ```

  Class `TestAutoQueueHandlerGet(unittest.TestCase)`:
  - `setUp`: Create `self.mock_persist = MagicMock(spec=AutoQueuePersist)` and `self.handler = AutoQueueHandler(self.mock_persist)`
  - `test_get_returns_200`: Set `self.mock_persist.patterns = set()`. Call `self.handler._AutoQueueHandler__handle_get_autoqueue()`. assertEqual(200, response.status_code).
  - `test_get_empty_returns_empty_json_array`: Set `self.mock_persist.patterns = set()`. Call handler. Parse body as JSON. assertEqual([], json.loads(response.body)).
  - `test_get_returns_sorted_patterns`: Create `AutoQueuePattern("beta")` and `AutoQueuePattern("alpha")`. Set `self.mock_persist.patterns = {beta_pat, alpha_pat}`. Call handler. Parse body as JSON. Verify the JSON array has "alpha" before "beta" (patterns are sorted by `.pattern` property).
  - `test_get_multiple_patterns`: Create 3 patterns. Set on mock. Call handler. Verify JSON array length matches.

  Class `TestAutoQueueHandlerAdd(unittest.TestCase)`:
  - `setUp`: Same as above.
  - `test_add_new_pattern_returns_200`: Set `self.mock_persist.patterns = set()`. Call `self.handler._AutoQueueHandler__handle_add_autoqueue(quote("newpattern"))`. assertEqual(200, response.status_code). assertIn("Added", response.body).
  - `test_add_calls_persist_add_pattern`: Same setup. After call, verify `self.mock_persist.add_pattern.assert_called_once()`. Verify the argument is an AutoQueuePattern with pattern "newpattern".
  - `test_add_duplicate_returns_409`: Create `AutoQueuePattern("existing")`. Set `self.mock_persist.patterns = {existing_pat}`. Call with `quote("existing")`. assertEqual(409, response.status_code). assertIn("already exists", response.body).
  - `test_add_blank_pattern_returns_400`: Set `self.mock_persist.patterns = set()`. Set `self.mock_persist.add_pattern.side_effect = ValueError("Blank pattern")`. Call with `quote("  ")`. assertEqual(400, response.status_code).
  - `test_add_url_decodes_pattern`: Set `self.mock_persist.patterns = set()`. Call with `quote("my pattern/test")`. Verify `self.mock_persist.add_pattern` was called with pattern matching "my pattern/test" (not the encoded form).
  - `test_add_special_characters`: Set `self.mock_persist.patterns = set()`. Call with `quote("file (2).txt")`. assertEqual(200, response.status_code).

  Class `TestAutoQueueHandlerRemove(unittest.TestCase)`:
  - `setUp`: Same as above.
  - `test_remove_existing_returns_200`: Create `AutoQueuePattern("toremove")`. Set `self.mock_persist.patterns = {pat}`. Call `self.handler._AutoQueueHandler__handle_remove_autoqueue(quote("toremove"))`. assertEqual(200, response.status_code). assertIn("Removed", response.body).
  - `test_remove_calls_persist_remove_pattern`: Same setup. Verify `self.mock_persist.remove_pattern.assert_called_once()`.
  - `test_remove_nonexistent_returns_404`: Set `self.mock_persist.patterns = set()`. Call with `quote("nonexistent")`. assertEqual(404, response.status_code). assertIn("doesn't exist", response.body).
  - `test_remove_url_decodes_pattern`: Create `AutoQueuePattern("my pattern")`. Set `self.mock_persist.patterns = {pat}`. Call with `quote("my pattern")`. assertEqual(200, response.status_code).

  **B. Create test_config_handler.py:**

  Copyright header: `# Copyright 2017, Inderpreet Singh, All rights reserved.`

  Imports:
  ```python
  import unittest
  from unittest.mock import MagicMock, patch, PropertyMock
  from urllib.parse import quote

  from common import Config, ConfigError
  from web.handler.config import ConfigHandler
  ```

  Class `TestConfigHandlerGet(unittest.TestCase)`:
  - `setUp`: Create `self.mock_config = MagicMock()` (no spec -- Config has dynamic section attributes). Create `self.handler = ConfigHandler(self.mock_config)`.
  - `test_get_returns_200`: Use `@patch('web.handler.config.SerializeConfig')` to mock the serializer. Set `mock_serialize.config.return_value = '{"test": "data"}'`. Call `self.handler._ConfigHandler__handle_get_config()`. assertEqual(200, response.status_code).
  - `test_get_body_is_serialized_config`: Same patch. Verify response.body equals what SerializeConfig.config() returned.

  Class `TestConfigHandlerSet(unittest.TestCase)`:
  - `setUp`: Create `self.mock_config = MagicMock()`. Create mock inner config: `self.mock_inner = MagicMock()`. Set `self.mock_config.has_section.return_value = True`. Set `setattr(self.mock_config, 'lftp', self.mock_inner)` or use `type(self.mock_config).lftp = PropertyMock(return_value=self.mock_inner)` -- since the handler uses `getattr(self.__config, section)`, a plain MagicMock will auto-return mocks for attribute access, so no special setup needed. Just ensure `self.mock_inner = getattr(self.mock_config, 'lftp')` after creating mock_config. Set `self.mock_inner.has_property.return_value = True`. Create handler.

  Actually, simpler approach: since MagicMock auto-creates attributes, just create `self.mock_config = MagicMock()` and set `self.mock_config.has_section.return_value = True`. Then `getattr(self.mock_config, 'lftp')` will return a MagicMock automatically. Capture that mock's `has_property` and `set_property`.

  - `test_set_valid_returns_200`: `self.mock_config.has_section.return_value = True`. Get the inner mock via `mock_inner = getattr(self.mock_config, 'lftp')`. Set `mock_inner.has_property.return_value = True`. Call `self.handler._ConfigHandler__handle_set_config("lftp", "remote_address", quote("192.168.1.1"))`. assertEqual(200, response.status_code). assertIn("set to", response.body).
  - `test_set_calls_set_property`: Same setup. Verify `mock_inner.set_property.assert_called_once_with("remote_address", "192.168.1.1")`.
  - `test_set_missing_section_returns_404`: `self.mock_config.has_section.return_value = False`. Call with section="nonexistent", key="key", value=quote("val"). assertEqual(404, response.status_code). assertIn("no section", response.body).
  - `test_set_missing_key_returns_404`: `self.mock_config.has_section.return_value = True`. `mock_inner = getattr(self.mock_config, 'lftp')`. `mock_inner.has_property.return_value = False`. Call with "lftp", "nonexistent_key", quote("val"). assertEqual(404, response.status_code). assertIn("no option", response.body).
  - `test_set_config_error_returns_400`: `self.mock_config.has_section.return_value = True`. `mock_inner = getattr(self.mock_config, 'lftp')`. `mock_inner.has_property.return_value = True`. `mock_inner.set_property.side_effect = ConfigError("Invalid value")`. Call handler. assertEqual(400, response.status_code). assertIn("Invalid value", response.body).
  - `test_set_url_decodes_value`: `self.mock_config.has_section.return_value = True`. `mock_inner = getattr(self.mock_config, 'lftp')`. `mock_inner.has_property.return_value = True`. Call with value=`quote("/path/with spaces")`. Verify set_property called with decoded value "/path/with spaces".
  - `test_set_value_with_slashes`: Same setup. Call with value=`quote("/remote/path/to/dir")`. Verify set_property called with decoded "/remote/path/to/dir".
  </action>
  <verify>
  Run from src/python/:
  - `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_web/test_handler/test_auto_queue_handler.py tests/unittests/test_web/test_handler/test_config_handler.py -v`
  All tests must pass. Expected: ~20 test methods, 0 failures.
  </verify>
  <done>
  test_auto_queue_handler.py has 3 test classes (TestAutoQueueHandlerGet, TestAutoQueueHandlerAdd, TestAutoQueueHandlerRemove) with ~12 test methods covering: GET returns sorted patterns as JSON, ADD succeeds/calls persist/returns 409 for duplicate/returns 400 for blank/URL-decodes, REMOVE succeeds/calls persist/returns 404 for nonexistent/URL-decodes.
  test_config_handler.py has 2 test classes (TestConfigHandlerGet, TestConfigHandlerSet) with ~9 test methods covering: GET returns serialized config, SET succeeds/calls set_property/returns 404 for missing section/returns 404 for missing key/returns 400 for ConfigError/URL-decodes values with slashes.
  All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test_server_handler.py and test_status_handler.py, run full regression</name>
  <files>
    src/python/tests/unittests/test_web/test_handler/test_server_handler.py
    src/python/tests/unittests/test_web/test_handler/test_status_handler.py
  </files>
  <action>
  Create the two simpler test files and run full regression to confirm zero new failures.

  **A. Create test_server_handler.py:**

  Copyright header: `# Copyright 2017, Inderpreet Singh, All rights reserved.`

  Imports:
  ```python
  import unittest
  from unittest.mock import MagicMock

  from web.handler.server import ServerHandler
  ```

  Class `TestServerHandler(unittest.TestCase)`:
  - `setUp`: Create `self.mock_context = MagicMock()` (Context mock -- only `.logger` is used, and MagicMock auto-creates `.logger.getChild()` return). Create `self.handler = ServerHandler(self.mock_context)`.
  - `test_initial_state_not_restart_requested`: Call `self.handler.is_restart_requested()`. assertFalse(result).
  - `test_restart_handler_returns_200`: Call `self.handler._ServerHandler__handle_action_restart()`. assertEqual(200, response.status_code).
  - `test_restart_handler_returns_requested_restart_body`: Call handler. assertEqual("Requested restart", response.body).
  - `test_restart_sets_restart_requested`: Call `self.handler._ServerHandler__handle_action_restart()`. Then call `self.handler.is_restart_requested()`. assertTrue(result).
  - `test_restart_idempotent`: Call `self.handler._ServerHandler__handle_action_restart()` twice. Call `self.handler.is_restart_requested()`. assertTrue(result). Both calls should return 200.
  - `test_restart_logs_info`: Call handler. Verify `self.handler.logger.info.assert_called_once()`. Verify the log message contains "restart".
  - `test_constructor_creates_child_logger`: Verify `self.mock_context.logger.getChild.assert_called_once_with("ServerActionHandler")`.

  **B. Create test_status_handler.py:**

  Copyright header: `# Copyright 2017, Inderpreet Singh, All rights reserved.`

  Imports:
  ```python
  import unittest
  from unittest.mock import MagicMock, patch

  from web.handler.status import StatusHandler
  ```

  Class `TestStatusHandler(unittest.TestCase)`:
  - `setUp`: Create `self.mock_status = MagicMock()`. Create `self.handler = StatusHandler(self.mock_status)`.
  - `test_get_status_returns_200`: Use `@patch('web.handler.status.SerializeStatusJson')` to mock the serializer. Set `mock_serialize.status.return_value = '{"server": {"up": true}}'`. Call `self.handler._StatusHandler__handle_get_status()`. assertEqual(200, response.status_code).
  - `test_get_status_body_is_serialized`: Same patch. Verify response.body equals the serializer return value.
  - `test_get_status_calls_serializer_with_status`: Same patch. Verify `mock_serialize.status.assert_called_once_with(self.mock_status)`.

  **C. Run full regression:**
  After creating both files, run the complete test suite to confirm zero new regressions.
  </action>
  <verify>
  Run from src/python/:

  1. Run only the new test files:
  `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_web/test_handler/test_server_handler.py tests/unittests/test_web/test_handler/test_status_handler.py -v`
  All tests must pass. Expected: ~10 test methods, 0 failures.

  2. Run ALL 4 new files from this plan together:
  `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_web/test_handler/test_auto_queue_handler.py tests/unittests/test_web/test_handler/test_config_handler.py tests/unittests/test_web/test_handler/test_server_handler.py tests/unittests/test_web/test_handler/test_status_handler.py -v`
  Expected: ~30 test methods, all passing.

  3. Run ALL tests to confirm zero regressions:
  `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest -q 2>&1 | tail -5`
  Must show 721+ tests with no NEW failures (pre-existing failures from missing lftp/ssh are acceptable).
  </verify>
  <done>
  test_server_handler.py has TestServerHandler with ~7 test methods covering: initial state false, restart returns 200 with correct body, restart sets flag, restart is idempotent, restart logs info, constructor creates child logger.
  test_status_handler.py has TestStatusHandler with ~3 test methods covering: GET returns 200, body matches serializer output, serializer called with status mock.
  All 4 new test files pass together (~30 tests total).
  All 721+ existing tests still pass with zero regressions.
  </done>
</task>

</tasks>

<verification>
Phase-level verification after both tasks complete:

1. **All 4 test files exist:**
   `ls src/python/tests/unittests/test_web/test_handler/test_auto_queue_handler.py src/python/tests/unittests/test_web/test_handler/test_config_handler.py src/python/tests/unittests/test_web/test_handler/test_server_handler.py src/python/tests/unittests/test_web/test_handler/test_status_handler.py`

2. **New tests pass in isolation:**
   `cd src/python && poetry run pytest tests/unittests/test_web/test_handler/test_auto_queue_handler.py tests/unittests/test_web/test_handler/test_config_handler.py tests/unittests/test_web/test_handler/test_server_handler.py tests/unittests/test_web/test_handler/test_status_handler.py -v`
   Expected: ~30 tests, all passing.

3. **Zero regressions in full suite:**
   `cd src/python && poetry run pytest -q`
   Expected: 721+ tests total, same pre-existing failure count as Phase 16 baseline.

4. **Copyright headers present:**
   Each file starts with `# Copyright 2017, Inderpreet Singh, All rights reserved.`

5. **Pattern compliance:**
   All tests use unittest.TestCase classes, MagicMock dependencies, name-mangled private method calls, and assert on HTTPResponse.status_code (int) and HTTPResponse.body (string).
</verification>

<success_criteria>
- 4 new test files exist in src/python/tests/unittests/test_web/test_handler/
- ~30 test methods across ~8 test classes covering all IHandler routes
- AutoQueueHandler: GET (sorted patterns, empty set), ADD (success, duplicate 409, blank 400, URL decode), REMOVE (success, nonexistent 404, URL decode)
- ConfigHandler: GET (serialized config), SET (success, missing section 404, missing key 404, ConfigError 400, URL decode, slashes in value)
- ServerHandler: Initial state false, restart returns 200, sets flag, idempotent, logs info, child logger
- StatusHandler: GET returns 200, body matches serializer, serializer called with status
- All new tests pass
- All 721+ existing tests still pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/17-web-handler-unit-tests/17-01-SUMMARY.md`

The SUMMARY must include:
- Exact count of new test methods added
- Exact count of test classes
- Full test suite pass/fail counts (showing zero new regressions)
- Any deviations from plan
</output>
