# Plan 01-03: Point Chart Data System

**Phase:** 1 -- Data Foundation
**Goal:** System contains versioned DVC point chart data (by resort, room type, view category, season, day-of-week) for current and upcoming years, with an API to query point costs and a UI to browse point charts.
**Requirements:** DATA-04, DATA-05
**Depends on:** Plan 01-01 (project skeleton, resorts.json), Plan 01-02 (API patterns, contract data for context)

## Context

Plan 01-01 created the `data/resorts.json` file defining all 17 resorts with their specific room types and view categories. Plan 01-02 established the API patterns (Pydantic schemas, FastAPI routers, TanStack Query hooks). This plan creates the point chart data storage system -- versioned JSON files containing per-night point costs organized by resort, year, season, room type + view, and day-of-week. It also provides an API for querying point costs and a browsable UI.

DVC point charts have a specific structure:
- **7 travel periods/seasons** per year (Adventure, Choice, Dream, Magic, Premier, Select, and Peak -- names may vary by year)
- **Date ranges** map specific calendar date spans to seasons (a season can have multiple non-contiguous date ranges)
- **Room types x view categories** form composite room identifiers that vary per resort
- **Weekday (Sun-Thu) vs weekend (Fri-Sat)** pricing
- **Values are points per night**
- **Charts are versioned by resort + year** (a new chart is published annually, usually in fall for the following year)

This plan creates the JSON schema, loads sample data for at least 2 resorts, and builds the lookup API. Actual point chart data entry for all resorts is a manual effort the user can do incrementally -- the system just needs to handle the full schema complexity.

## Tasks

### 1. Point chart JSON schema, sample data files, and data loader

**File(s):**
- `data/point_charts/README.md`
- `data/point_charts/polynesian_2026.json`
- `data/point_charts/riviera_2026.json`
- `data/point_charts/schema.json`
- `backend/data/point_charts.py`
- `backend/api/schemas.py` (extend)
- `tests/test_point_charts.py`

**Action:** Define the point chart JSON schema and create sample data.

**`data/point_charts/schema.json`:** JSON Schema for validation:
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "DVC Point Chart",
  "type": "object",
  "required": ["resort", "year", "seasons"],
  "properties": {
    "resort": {
      "type": "string",
      "description": "Resort slug matching data/resorts.json"
    },
    "year": {
      "type": "integer",
      "description": "Calendar year this chart applies to (e.g., 2026)"
    },
    "seasons": {
      "type": "array",
      "items": {
        "type": "object",
        "required": ["name", "date_ranges", "rooms"],
        "properties": {
          "name": {
            "type": "string",
            "description": "Season/travel period name (e.g., Adventure, Dream, Premier)"
          },
          "date_ranges": {
            "type": "array",
            "items": {
              "type": "array",
              "items": { "type": "string", "format": "date" },
              "minItems": 2,
              "maxItems": 2
            },
            "description": "Array of [start_date, end_date] pairs. A season can span multiple non-contiguous date ranges."
          },
          "rooms": {
            "type": "object",
            "description": "Keys are composite room identifiers: {room_type}_{view_category} (e.g., 'deluxe_studio_standard', 'one_bedroom_lake', 'bungalow_theme_park'). Values are point costs.",
            "additionalProperties": {
              "type": "object",
              "required": ["weekday", "weekend"],
              "properties": {
                "weekday": { "type": "integer", "minimum": 1, "description": "Points per night Sun-Thu" },
                "weekend": { "type": "integer", "minimum": 1, "description": "Points per night Fri-Sat" }
              }
            }
          }
        }
      }
    }
  }
}
```

The room key format `{room_type}_{view_category}` accommodates resort-specific variations. For example:
- Polynesian: `deluxe_studio_standard`, `deluxe_studio_lake`, `deluxe_studio_theme_park`, `bungalow_lake`, `bungalow_theme_park`
- Riviera: `tower_studio_standard`, `tower_studio_preferred`, `deluxe_studio_standard`, `deluxe_studio_preferred`
- Beach Club: `deluxe_studio_standard` (only one view category)
- Grand Floridian: `resort_studio_standard`, `resort_studio_lake`, `resort_studio_theme_park`, `deluxe_studio_standard`, etc.

This schema handles 3 to 30+ room/view combinations per resort without requiring schema changes.

**`data/point_charts/polynesian_2026.json`:** Sample point chart for Polynesian Villas 2026. Include all 7 seasons with realistic date ranges and point costs for all room type + view combinations. Use actual or closely approximated DVC point values. Structure:

```json
{
  "resort": "polynesian",
  "year": 2026,
  "seasons": [
    {
      "name": "Adventure",
      "date_ranges": [
        ["2026-01-01", "2026-01-31"],
        ["2026-09-01", "2026-09-30"]
      ],
      "rooms": {
        "deluxe_studio_standard": { "weekday": 14, "weekend": 19 },
        "deluxe_studio_lake": { "weekday": 22, "weekend": 28 },
        "deluxe_studio_theme_park": { "weekday": 27, "weekend": 34 },
        "one_bedroom_standard": { "weekday": 25, "weekend": 30 },
        "one_bedroom_lake": { "weekday": 32, "weekend": 38 },
        "one_bedroom_theme_park": { "weekday": 38, "weekend": 45 },
        "two_bedroom_standard": { "weekday": 36, "weekend": 44 },
        "two_bedroom_lake": { "weekday": 46, "weekend": 55 },
        "two_bedroom_theme_park": { "weekday": 54, "weekend": 64 },
        "bungalow_lake": { "weekday": 79, "weekend": 95 },
        "bungalow_theme_park": { "weekday": 88, "weekend": 106 }
      }
    },
    {
      "name": "Choice",
      "date_ranges": [
        ["2026-02-01", "2026-02-14"]
      ],
      "rooms": {
        "deluxe_studio_standard": { "weekday": 16, "weekend": 22 },
        "deluxe_studio_lake": { "weekday": 24, "weekend": 32 },
        "deluxe_studio_theme_park": { "weekday": 30, "weekend": 38 },
        "one_bedroom_standard": { "weekday": 28, "weekend": 34 },
        "one_bedroom_lake": { "weekday": 36, "weekend": 43 },
        "one_bedroom_theme_park": { "weekday": 43, "weekend": 51 },
        "two_bedroom_standard": { "weekday": 41, "weekend": 50 },
        "two_bedroom_lake": { "weekday": 52, "weekend": 63 },
        "two_bedroom_theme_park": { "weekday": 62, "weekend": 73 },
        "bungalow_lake": { "weekday": 90, "weekend": 109 },
        "bungalow_theme_park": { "weekday": 100, "weekend": 121 }
      }
    },
    {
      "name": "Dream",
      "date_ranges": [
        ["2026-02-15", "2026-03-07"],
        ["2026-06-14", "2026-08-13"]
      ],
      "rooms": {
        "deluxe_studio_standard": { "weekday": 20, "weekend": 26 },
        "deluxe_studio_lake": { "weekday": 29, "weekend": 38 },
        "deluxe_studio_theme_park": { "weekday": 36, "weekend": 46 },
        "one_bedroom_standard": { "weekday": 34, "weekend": 41 },
        "one_bedroom_lake": { "weekday": 44, "weekend": 52 },
        "one_bedroom_theme_park": { "weekday": 52, "weekend": 62 },
        "two_bedroom_standard": { "weekday": 50, "weekend": 61 },
        "two_bedroom_lake": { "weekday": 64, "weekend": 77 },
        "two_bedroom_theme_park": { "weekday": 75, "weekend": 89 },
        "bungalow_lake": { "weekday": 110, "weekend": 133 },
        "bungalow_theme_park": { "weekday": 122, "weekend": 147 }
      }
    },
    {
      "name": "Magic",
      "date_ranges": [
        ["2026-03-08", "2026-04-11"],
        ["2026-11-25", "2026-12-23"]
      ],
      "rooms": {
        "deluxe_studio_standard": { "weekday": 22, "weekend": 29 },
        "deluxe_studio_lake": { "weekday": 33, "weekend": 42 },
        "deluxe_studio_theme_park": { "weekday": 40, "weekend": 51 },
        "one_bedroom_standard": { "weekday": 38, "weekend": 46 },
        "one_bedroom_lake": { "weekday": 49, "weekend": 58 },
        "one_bedroom_theme_park": { "weekday": 58, "weekend": 69 },
        "two_bedroom_standard": { "weekday": 56, "weekend": 68 },
        "two_bedroom_lake": { "weekday": 71, "weekend": 86 },
        "two_bedroom_theme_park": { "weekday": 84, "weekend": 99 },
        "bungalow_lake": { "weekday": 123, "weekend": 148 },
        "bungalow_theme_park": { "weekday": 136, "weekend": 164 }
      }
    },
    {
      "name": "Premier",
      "date_ranges": [
        ["2026-12-24", "2026-12-31"]
      ],
      "rooms": {
        "deluxe_studio_standard": { "weekday": 28, "weekend": 36 },
        "deluxe_studio_lake": { "weekday": 41, "weekend": 53 },
        "deluxe_studio_theme_park": { "weekday": 51, "weekend": 64 },
        "one_bedroom_standard": { "weekday": 48, "weekend": 58 },
        "one_bedroom_lake": { "weekday": 61, "weekend": 73 },
        "one_bedroom_theme_park": { "weekday": 73, "weekend": 87 },
        "two_bedroom_standard": { "weekday": 70, "weekend": 85 },
        "two_bedroom_lake": { "weekday": 89, "weekend": 108 },
        "two_bedroom_theme_park": { "weekday": 106, "weekend": 126 },
        "bungalow_lake": { "weekday": 154, "weekend": 186 },
        "bungalow_theme_park": { "weekday": 171, "weekend": 206 }
      }
    },
    {
      "name": "Select",
      "date_ranges": [
        ["2026-04-12", "2026-06-13"],
        ["2026-08-14", "2026-08-31"],
        ["2026-10-01", "2026-11-24"]
      ],
      "rooms": {
        "deluxe_studio_standard": { "weekday": 17, "weekend": 23 },
        "deluxe_studio_lake": { "weekday": 26, "weekend": 33 },
        "deluxe_studio_theme_park": { "weekday": 32, "weekend": 40 },
        "one_bedroom_standard": { "weekday": 30, "weekend": 36 },
        "one_bedroom_lake": { "weekday": 38, "weekend": 45 },
        "one_bedroom_theme_park": { "weekday": 45, "weekend": 54 },
        "two_bedroom_standard": { "weekday": 43, "weekend": 53 },
        "two_bedroom_lake": { "weekday": 55, "weekend": 67 },
        "two_bedroom_theme_park": { "weekday": 65, "weekend": 77 },
        "bungalow_lake": { "weekday": 95, "weekend": 115 },
        "bungalow_theme_park": { "weekday": 105, "weekend": 127 }
      }
    }
  ]
}
```

Note: The above is 6 seasons as a practical starting point. Real DVC 2026 charts may have 7 (Adventure, Choice, Dream, Magic, Peak, Premier, Select). The executor should include all 7 if known, or use these 6 as representative. The schema supports any number of seasons. Every calendar day of the year MUST be covered by exactly one season's date ranges (no gaps, no overlaps).

**`data/point_charts/riviera_2026.json`:** Sample point chart for Riviera Resort 2026. Include tower_studio (unique to Riviera) and standard/preferred view variations. Structure mirrors polynesian but with different room types: `tower_studio_standard`, `tower_studio_preferred`, `deluxe_studio_standard`, `deluxe_studio_preferred`, `one_bedroom_standard`, `one_bedroom_preferred`, etc.

**`data/point_charts/README.md`:** Brief documentation explaining:
- File naming convention: `{resort_slug}_{year}.json`
- How to add a new chart: copy an existing file, update resort/year/values
- Where to find official point chart data (DVC website, dvcfan.com, wdwinfo.com)
- Room key format: `{room_type}_{view_category}`
- Date range rules: every day of the year must be covered exactly once

**`backend/data/point_charts.py`:** Data loader:
```python
import json
from pathlib import Path
from functools import lru_cache
from datetime import date

CHARTS_DIR = Path(__file__).parent.parent.parent / "data" / "point_charts"

@lru_cache
def load_point_chart(resort_slug: str, year: int) -> dict | None:
    """Load a point chart from JSON file. Returns None if not found."""
    file_path = CHARTS_DIR / f"{resort_slug}_{year}.json"
    if not file_path.exists():
        return None
    with open(file_path) as f:
        return json.load(f)

def get_available_charts() -> list[dict]:
    """List all available point chart files with resort and year."""
    charts = []
    for f in CHARTS_DIR.glob("*.json"):
        if f.name == "schema.json":
            continue
        parts = f.stem.rsplit("_", 1)  # split on last underscore to get year
        if len(parts) == 2:
            try:
                charts.append({"resort": parts[0], "year": int(parts[1]), "file": f.name})
            except ValueError:
                continue
    return sorted(charts, key=lambda c: (c["resort"], c["year"]))

def get_season_for_date(chart: dict, target_date: date) -> dict | None:
    """Find which season a target date falls into."""
    for season in chart["seasons"]:
        for start_str, end_str in season["date_ranges"]:
            start = date.fromisoformat(start_str)
            end = date.fromisoformat(end_str)
            if start <= target_date <= end:
                return season
    return None

def get_point_cost(chart: dict, room_key: str, target_date: date) -> int | None:
    """Get the point cost for a specific room on a specific date.

    Args:
        chart: loaded point chart dict
        room_key: composite key like 'deluxe_studio_lake'
        target_date: the date to look up

    Returns:
        Point cost (integer) or None if room/date not found.
    """
    season = get_season_for_date(chart, target_date)
    if season is None:
        return None
    room = season["rooms"].get(room_key)
    if room is None:
        return None
    # Friday (4) and Saturday (5) are weekend
    is_weekend = target_date.weekday() in (4, 5)
    return room["weekend"] if is_weekend else room["weekday"]

def calculate_stay_cost(resort_slug: str, room_key: str, check_in: date, check_out: date) -> dict | None:
    """Calculate total point cost for a stay.

    Returns dict with per-night breakdown and total, or None if chart not found.
    """
    year = check_in.year
    chart = load_point_chart(resort_slug, year)
    if chart is None:
        return None

    nights = []
    total = 0
    current = check_in
    while current < check_out:
        cost = get_point_cost(chart, room_key, current)
        if cost is None:
            # Date might span into next year's chart
            next_chart = load_point_chart(resort_slug, current.year)
            if next_chart and next_chart != chart:
                cost = get_point_cost(next_chart, room_key, current)
            if cost is None:
                return None  # missing data
        nights.append({
            "date": current.isoformat(),
            "day_of_week": current.strftime("%A"),
            "season": get_season_for_date(chart, current)["name"] if get_season_for_date(chart, current) else "Unknown",
            "is_weekend": current.weekday() in (4, 5),
            "points": cost
        })
        total += cost
        current += __import__("datetime").timedelta(days=1)

    return {
        "resort": resort_slug,
        "room": room_key,
        "check_in": check_in.isoformat(),
        "check_out": check_out.isoformat(),
        "num_nights": len(nights),
        "total_points": total,
        "nightly_breakdown": nights
    }
```

The `calculate_stay_cost` function handles multi-night stays that cross season boundaries and weekday/weekend transitions. It also handles year boundaries by loading the next year's chart if needed.

**Pydantic schemas (extend `backend/api/schemas.py`):**
```python
class PointChartSummary(BaseModel):
    resort: str
    year: int
    file: str

class PointCostRequest(BaseModel):
    resort: str
    room_key: str
    check_in: str  # ISO date
    check_out: str  # ISO date

class NightlyCost(BaseModel):
    date: str
    day_of_week: str
    season: str
    is_weekend: bool
    points: int

class StayCostResponse(BaseModel):
    resort: str
    room: str
    check_in: str
    check_out: str
    num_nights: int
    total_points: int
    nightly_breakdown: list[NightlyCost]
```

**`tests/test_point_charts.py`:** Test the data loader and cost calculations:
- `load_point_chart("polynesian", 2026)` returns valid chart with 6+ seasons
- `load_point_chart("nonexistent", 2026)` returns None
- `get_available_charts()` includes polynesian_2026 and riviera_2026
- `get_season_for_date(chart, date(2026, 1, 15))` returns Adventure season (Jan is Adventure)
- `get_season_for_date(chart, date(2026, 7, 1))` returns Dream season (July is Dream)
- `get_point_cost(chart, "deluxe_studio_standard", date(2026, 1, 15))` returns 14 (weekday Adventure)
- `get_point_cost(chart, "deluxe_studio_standard", date(2026, 1, 16))` returns 19 if Friday (weekend)
- `get_point_cost(chart, "nonexistent_room", date(2026, 1, 15))` returns None
- `calculate_stay_cost("polynesian", "deluxe_studio_standard", date(2026, 1, 12), date(2026, 1, 15))` returns correct total for 3-night Mon-Wed stay (3 x weekday Adventure = 3 x 14 = 42)
- Test a stay spanning weekday and weekend: check correct weekday/weekend split
- Test a stay spanning two seasons: check correct season assignment per night
- Validate both sample charts have no date gaps (every day of 2026 is covered by a season)
- Riviera chart: `tower_studio_standard` room key exists and returns valid costs

### 2. Point chart API endpoints

**File(s):**
- `backend/api/point_charts.py`
- `backend/main.py` (wire router)
- `tests/test_api_point_charts.py`

**Action:** Create API endpoints for querying point charts.

**`backend/api/point_charts.py`:** FastAPI router with prefix `/api/point-charts`.

Endpoints:

- `GET /api/point-charts` -- List all available charts. Returns `list[PointChartSummary]` (resort slug, year, filename).

- `GET /api/point-charts/{resort}/{year}` -- Get a specific resort's point chart for a year. Returns the full chart JSON including all seasons and room types. Returns 404 if chart not found.

- `GET /api/point-charts/{resort}/{year}/rooms` -- Get just the room types available for this resort/year. Extracts unique room keys from the first season's rooms object. Returns:
  ```json
  {
    "resort": "polynesian",
    "year": 2026,
    "rooms": [
      {"key": "deluxe_studio_standard", "room_type": "Deluxe Studio", "view": "Standard"},
      {"key": "deluxe_studio_lake", "room_type": "Deluxe Studio", "view": "Lake"},
      {"key": "bungalow_theme_park", "room_type": "Bungalow", "view": "Theme Park"}
    ]
  }
  ```
  Parse room keys by splitting on the last occurrence pattern: everything before the last known view category is the room type, the rest is the view. Use the resort's `view_categories` from `resorts.json` to identify the view portion. Humanize the names (underscores to title case).

- `GET /api/point-charts/{resort}/{year}/seasons` -- Get the season structure (names and date ranges) without room costs. Useful for the UI to display season calendar.

- `POST /api/point-charts/calculate` -- Calculate stay cost. Accepts `PointCostRequest` body. Returns `StayCostResponse`. Returns 404 if chart not found, 400 if room key invalid or dates out of range.

Wire the router into `backend/main.py`.

**`tests/test_api_point_charts.py`:**
- GET /api/point-charts -> returns list including polynesian 2026 and riviera 2026
- GET /api/point-charts/polynesian/2026 -> returns full chart JSON
- GET /api/point-charts/polynesian/2026/rooms -> returns room list with parsed names
- GET /api/point-charts/polynesian/2026/seasons -> returns season names and date ranges
- GET /api/point-charts/nonexistent/2026 -> 404
- POST /api/point-charts/calculate with valid data -> returns stay cost with nightly breakdown
- POST /api/point-charts/calculate with invalid room -> 400
- POST /api/point-charts/calculate with missing chart -> 404
- Verify nightly breakdown correctly distinguishes weekday vs weekend pricing
- Verify multi-season stay is calculated correctly

### 3. Point chart browser UI

**File(s):**
- `frontend/src/pages/PointChartsPage.tsx`
- `frontend/src/components/PointChartTable.tsx`
- `frontend/src/components/SeasonCalendar.tsx`
- `frontend/src/components/StayCostCalculator.tsx`
- `frontend/src/hooks/usePointCharts.ts`
- `frontend/src/types/index.ts` (extend with point chart types)

**Action:** Build the point chart browsing and cost calculation UI.

**`frontend/src/types/index.ts`:** Add point chart types:
```typescript
export interface PointChart {
  resort: string;
  year: number;
  seasons: Season[];
}

export interface Season {
  name: string;
  date_ranges: [string, string][];
  rooms: Record<string, { weekday: number; weekend: number }>;
}

export interface RoomInfo {
  key: string;
  room_type: string;
  view: string;
}

export interface PointChartSummary {
  resort: string;
  year: number;
  file: string;
}

export interface NightlyCost {
  date: string;
  day_of_week: string;
  season: string;
  is_weekend: boolean;
  points: number;
}

export interface StayCostResponse {
  resort: string;
  room: string;
  check_in: string;
  check_out: string;
  num_nights: number;
  total_points: number;
  nightly_breakdown: NightlyCost[];
}
```

**`frontend/src/hooks/usePointCharts.ts`:** TanStack Query hooks:
```typescript
export function useAvailableCharts() {
  return useQuery({ queryKey: ["point-charts"], queryFn: () => api.get<PointChartSummary[]>("/point-charts") });
}
export function usePointChart(resort: string, year: number) {
  return useQuery({ queryKey: ["point-charts", resort, year], queryFn: () => api.get<PointChart>(`/point-charts/${resort}/${year}`), enabled: !!resort && !!year });
}
export function useChartRooms(resort: string, year: number) {
  return useQuery({ queryKey: ["point-charts", resort, year, "rooms"], queryFn: () => api.get(`/point-charts/${resort}/${year}/rooms`), enabled: !!resort && !!year });
}
export function useCalculateStayCost() {
  return useMutation({ mutationFn: (data: PointCostRequest) => api.post<StayCostResponse>("/point-charts/calculate", data) });
}
```

**`frontend/src/pages/PointChartsPage.tsx`:** Replace placeholder. Layout:
1. **Header:** "Point Charts" title
2. **Chart selector:** Two dropdowns side by side -- Resort (populated from available charts, showing human-readable resort names) and Year. Default to first available chart.
3. **Tabs** below selector: "Point Chart" | "Season Calendar" | "Cost Calculator"
4. Default tab shows `PointChartTable`, second shows `SeasonCalendar`, third shows `StayCostCalculator`

**`frontend/src/components/PointChartTable.tsx`:** Display point costs as a table.
- Columns: Room Type | View | then one column pair per season (Weekday / Weekend)
- Rows: each room type + view combination
- Cells: point values
- Color-code cells: lower values in green/cool, higher values in red/warm (heat map effect) using Tailwind bg opacity classes
- Show room type and view as separate columns for clarity
- Responsive: horizontally scrollable on mobile
- Use shadcn Table component

**`frontend/src/components/SeasonCalendar.tsx`:** Visual calendar showing which dates map to which seasons.
- Display a 12-month calendar grid for the selected year
- Each day is color-coded by season (7 distinct colors)
- Legend at bottom mapping colors to season names
- Highlight weekends (Fri/Sat) with a subtle indicator (dot or border)
- Use a simple CSS grid (not a heavy calendar library) -- each month is a mini grid of day cells

**`frontend/src/components/StayCostCalculator.tsx`:** Quick cost lookup tool.
- Inputs: Check-in date (date picker), Check-out date (date picker), Room type + view (select dropdown populated from the selected chart's rooms)
- "Calculate" button triggers the API call
- Results display: Total points in large text, plus nightly breakdown table (Date | Day | Season | Weekend? | Points)
- Show average points per night
- Validate: check-out must be after check-in, max 14 nights, dates must be within the selected chart's year

## Verification

1. **Point chart data loads:**
   ```bash
   curl http://localhost:8000/api/point-charts
   # Returns [{"resort":"polynesian","year":2026,...}, {"resort":"riviera","year":2026,...}]

   curl http://localhost:8000/api/point-charts/polynesian/2026
   # Returns full chart JSON with 6+ seasons, all room types

   curl http://localhost:8000/api/point-charts/polynesian/2026/rooms
   # Returns parsed room list with human-readable names
   ```

2. **Cost calculation works:**
   ```bash
   curl -X POST http://localhost:8000/api/point-charts/calculate \
     -H "Content-Type: application/json" \
     -d '{"resort":"polynesian","room_key":"deluxe_studio_standard","check_in":"2026-01-12","check_out":"2026-01-15"}'
   # Returns: total_points=42 (3 weekday nights x 14 pts in Adventure season)

   # Weekend test:
   curl -X POST http://localhost:8000/api/point-charts/calculate \
     -H "Content-Type: application/json" \
     -d '{"resort":"polynesian","room_key":"deluxe_studio_standard","check_in":"2026-01-09","check_out":"2026-01-12"}'
   # Fri Jan 9 = 19 (weekend), Sat Jan 10 = 19 (weekend), Sun Jan 11 = 14 (weekday) = 52 total
   ```

3. **Frontend UI:**
   - Visit http://localhost:5173/point-charts
   - Select Polynesian 2026 from dropdown
   - Point Chart tab: table shows all rooms with per-season weekday/weekend costs
   - Season Calendar tab: 12-month calendar with color-coded seasons
   - Cost Calculator tab: select dates and room, click calculate, see nightly breakdown
   - Switch to Riviera 2026 -- see tower_studio rooms (unique to Riviera)

4. **Tests:**
   ```bash
   pytest tests/test_point_charts.py tests/test_api_point_charts.py -v
   # All pass -- data loading, cost calculation, season lookup, API endpoints
   ```

5. **Data integrity:** Verify every day of 2026 is covered by exactly one season in each sample chart (no gaps, no overlaps). The test suite should include a test that iterates all 365 days and asserts `get_season_for_date` returns non-None for each.

## Notes

- Point chart JSON files are stored in `data/point_charts/` as flat files, not in the database. This is per the architecture decision: "Point charts stored as versioned data, not code." JSON files are easy to version in git, manually edit, and validate.
- The `lru_cache` on `load_point_chart` means charts are loaded once and cached in memory. For a single-user app this is fine. If charts need to be reloaded without restart, add a cache-clear endpoint (not needed for v1).
- Room keys use the `{room_type}_{view_category}` composite format rather than separate fields because it maps cleanly to JSON object keys and avoids nested structures. The API's `/rooms` endpoint parses these back into human-readable components for the UI.
- The sample data uses realistic but approximate point values. The user will need to enter actual values from published DVC point charts. The README in the data directory explains how to do this.
- The `calculate_stay_cost` function handles year boundaries (a stay starting in December 2026 and ending in January 2027 would need both the 2026 and 2027 charts). If the 2027 chart doesn't exist yet, the calculation fails gracefully with a clear error.
- Date range validation in the sample charts: every day of 2026 must be covered by exactly one season. The test suite enforces this. When users add new charts, the same validation should be applied.
- The season calendar component uses a simple CSS grid, not a calendar library. This keeps the bundle small and avoids dependency on a heavy date picker library for what is essentially a read-only visualization.
