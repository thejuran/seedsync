# Plan 01-02: Contract & Point Balance Management

**Phase:** 1 -- Data Foundation
**Goal:** User can add/edit/remove DVC contracts, enter and view point balances (current/banked/borrowed/holding) per contract, view a use year timeline per contract, and see which resorts each contract is eligible to book at based on resale/direct status.
**Requirements:** DATA-01, DATA-02, DATA-03, PNTS-01, PNTS-02, PNTS-03
**Depends on:** Plan 01-01 (project skeleton, models, database)

## Context

Plan 01-01 created the project skeleton, database models (Contract, PointBalance), use year date math utilities, resort reference data, and stub API routes. This plan builds the complete CRUD API for contracts and point balances, the resale eligibility engine logic, and the full React UI for managing contracts and viewing point summaries. By the end of this plan, a user can perform all contract and point management operations through the browser.

Key domain rules this plan must encode:
- **Use years:** 8 valid start months (Feb, Mar, Apr, Jun, Aug, Sep, Oct, Dec). Points run from 1st of UY month through last day before the next UY.
- **Banking:** 100% of current year points can be banked. Deadline is 8 months into the use year. Banked points cannot be re-banked.
- **Borrowing:** Up to configurable % (currently 100%) of next year's allotment. Reduces next year's balance.
- **Resale restrictions:** Original 14 resorts (pre-Jan 2019): resale can book any of those 14. Post-2019 resorts (Riviera, DLH, Cabins at FW): resale can ONLY book home resort. Direct: no restrictions.

## Tasks

### 1. Contract CRUD API + Pydantic schemas + eligibility engine

**File(s):**
- `backend/api/contracts.py`
- `backend/api/schemas.py`
- `backend/engine/eligibility.py`
- `backend/main.py` (wire routers)
- `tests/test_api_contracts.py`
- `tests/test_eligibility.py`

**Action:** Build the complete contract management API and resale eligibility logic.

**`backend/api/schemas.py`:** Create Pydantic v2 models for request/response validation.

```python
from pydantic import BaseModel, Field, field_validator
from typing import Optional
from datetime import datetime

VALID_USE_YEAR_MONTHS = [2, 3, 4, 6, 8, 9, 10, 12]

class ContractCreate(BaseModel):
    name: Optional[str] = None
    home_resort: str = Field(..., min_length=1)
    use_year_month: int
    annual_points: int = Field(..., gt=0, le=2000)  # DVC contracts rarely exceed ~1000 pts
    purchase_type: str = Field(..., pattern="^(resale|direct)$")

    @field_validator("use_year_month")
    @classmethod
    def validate_use_year_month(cls, v):
        if v not in VALID_USE_YEAR_MONTHS:
            raise ValueError(f"Use year month must be one of {VALID_USE_YEAR_MONTHS}")
        return v

    @field_validator("home_resort")
    @classmethod
    def validate_home_resort(cls, v):
        from backend.data.resorts import get_resort_slugs
        if v not in get_resort_slugs():
            raise ValueError(f"Invalid resort slug. Must be one of: {get_resort_slugs()}")
        return v

class ContractUpdate(BaseModel):
    name: Optional[str] = None
    home_resort: Optional[str] = None
    use_year_month: Optional[int] = None
    annual_points: Optional[int] = Field(None, gt=0, le=2000)
    purchase_type: Optional[str] = Field(None, pattern="^(resale|direct)$")

    @field_validator("use_year_month")
    @classmethod
    def validate_use_year_month(cls, v):
        if v is not None and v not in VALID_USE_YEAR_MONTHS:
            raise ValueError(f"Use year month must be one of {VALID_USE_YEAR_MONTHS}")
        return v

    @field_validator("home_resort")
    @classmethod
    def validate_home_resort(cls, v):
        if v is not None:
            from backend.data.resorts import get_resort_slugs
            if v not in get_resort_slugs():
                raise ValueError(f"Invalid resort slug.")
        return v

class ContractResponse(BaseModel):
    id: int
    name: Optional[str]
    home_resort: str
    use_year_month: int
    annual_points: int
    purchase_type: str
    created_at: datetime
    updated_at: datetime

    model_config = {"from_attributes": True}

class PointBalanceCreate(BaseModel):
    contract_id: int
    use_year: int = Field(..., ge=2020, le=2035)
    allocation_type: str = Field(..., pattern="^(current|banked|borrowed|holding)$")
    points: int = Field(..., ge=0)

class PointBalanceUpdate(BaseModel):
    points: int = Field(..., ge=0)

class PointBalanceResponse(BaseModel):
    id: int
    contract_id: int
    use_year: int
    allocation_type: str
    points: int
    updated_at: datetime

    model_config = {"from_attributes": True}
```

**`backend/api/contracts.py`:** Replace the stub router with full CRUD.

Endpoints:
- `GET /api/contracts` -- List all contracts. Returns `list[ContractResponse]`. Include `eligible_resorts` field (list of resort slugs this contract can book at) computed by the eligibility engine.
- `GET /api/contracts/{id}` -- Get single contract with its point balances and eligible resorts.
- `POST /api/contracts` -- Create a contract. Accepts `ContractCreate`. Returns `ContractResponse` with 201 status.
- `PUT /api/contracts/{id}` -- Update a contract. Accepts `ContractUpdate` (partial update). Returns `ContractResponse`.
- `DELETE /api/contracts/{id}` -- Delete a contract and cascade-delete its point balances. Returns 204.

For the list endpoint, return an enriched response that includes:
```python
class ContractWithDetails(ContractResponse):
    point_balances: list[PointBalanceResponse] = []
    eligible_resorts: list[str] = []  # resort slugs
    use_year_timeline: dict = {}       # computed use year dates
```

The `use_year_timeline` should include (for the current use year):
- `use_year_start`: date string
- `use_year_end`: date string
- `banking_deadline`: date string
- `days_until_banking_deadline`: int (negative if past)
- `is_banking_window_open`: bool

Compute these using `backend/engine/use_year.py` functions from Plan 01-01.

**`backend/engine/eligibility.py`:** Replace the stub with the complete eligibility resolver.

```python
from backend.data.resorts import get_resort_slugs, get_original_resort_slugs, get_restricted_resort_slugs

def get_eligible_resorts(home_resort: str, purchase_type: str) -> list[str]:
    """
    Determine which resorts a contract can book at.

    Rules:
    - Direct purchase: can book at ALL resorts
    - Resale at original 14 resort: can book at any of the original 14
    - Resale at restricted resort (Riviera, DLH, Cabins FW): can ONLY book home resort
    """
    if purchase_type == "direct":
        return get_resort_slugs()  # all resorts

    # Resale contract
    original = get_original_resort_slugs()
    restricted = get_restricted_resort_slugs()

    if home_resort in restricted:
        # Post-2019 resort resale: home resort only
        return [home_resort]
    else:
        # Original 14 resort resale: can book any of the original 14
        return original
```

Note: Resale contracts at original 14 resorts can book at any of the original 14, but NOT at restricted resorts. This is a critical rule -- if home_resort is "polynesian" (original) and purchase_type is "resale", eligible resorts are the 14 originals only, not Riviera/DLH/Cabins.

**Wire into `backend/main.py`:** Ensure the contracts router is included with `app.include_router(contracts_router)`.

**`tests/test_eligibility.py`:** Test all resale restriction scenarios:
- Direct purchase at any resort: returns all 17 resorts
- Resale at polynesian (original): returns exactly the 14 original resort slugs
- Resale at riviera (restricted): returns `["riviera"]` only
- Resale at disneyland_hotel (restricted): returns `["disneyland_hotel"]` only
- Resale at cabins_fort_wilderness (restricted): returns `["cabins_fort_wilderness"]` only
- Resale at bay_lake_tower (original): returns the 14 original resort slugs (not 17)
- Verify no restricted resorts appear in resale-at-original results

**`tests/test_api_contracts.py`:** Integration tests using FastAPI TestClient (httpx):
- POST /api/contracts with valid data -> 201, returns contract
- POST /api/contracts with invalid use_year_month (e.g., 5) -> 422 validation error
- POST /api/contracts with invalid resort slug -> 422 validation error
- GET /api/contracts -> returns list including created contract
- GET /api/contracts/{id} -> returns contract with point_balances, eligible_resorts, use_year_timeline
- PUT /api/contracts/{id} -> updates specified fields only
- DELETE /api/contracts/{id} -> 204
- GET /api/contracts/{deleted_id} -> 404

### 2. Point balance API + use year timeline computation

**File(s):**
- `backend/api/points.py`
- `backend/engine/use_year.py` (extend)
- `tests/test_api_points.py`

**Action:** Build the point balance management API and use year timeline.

**`backend/api/points.py`:** Replace the stub router with full CRUD for point balances.

Endpoints:
- `GET /api/contracts/{contract_id}/points` -- Get all point balances for a contract, grouped by use year. Returns:
  ```json
  {
    "contract_id": 1,
    "contract_name": "Our Poly contract",
    "annual_points": 160,
    "balances_by_year": {
      "2025": {
        "current": 0,
        "banked": 45,
        "borrowed": 0,
        "holding": 0,
        "total": 45
      },
      "2026": {
        "current": 160,
        "banked": 0,
        "borrowed": 30,
        "holding": 0,
        "total": 190
      }
    },
    "grand_total": 235
  }
  ```
- `POST /api/contracts/{contract_id}/points` -- Add a point balance entry. Accepts `PointBalanceCreate` (contract_id from URL, not body). Returns `PointBalanceResponse` with 201.
- `PUT /api/points/{id}` -- Update point amount. Accepts `PointBalanceUpdate`. Returns `PointBalanceResponse`.
- `DELETE /api/points/{id}` -- Delete a point balance entry. Returns 204.

The POST endpoint should validate:
- Contract exists (404 if not)
- No duplicate entry for same contract + use_year + allocation_type (409 Conflict if exists -- update instead)
- Banked points cannot exceed the contract's annual_points
- Borrowed points log a warning if they exceed 100% of annual_points (do NOT reject -- borrowing limit is configurable and may change)

**`GET /api/contracts/{contract_id}/timeline`:** New endpoint returning the complete use year timeline for a contract. For the current year and next year:
```json
{
  "contract_id": 1,
  "use_year_month": 6,
  "timelines": [
    {
      "use_year": 2025,
      "label": "2025 Use Year",
      "start": "2025-06-01",
      "end": "2026-05-31",
      "banking_deadline": "2026-01-31",
      "banking_deadline_passed": true,
      "days_until_banking_deadline": -40,
      "point_expiration": "2026-05-31",
      "days_until_expiration": 110,
      "status": "active"
    },
    {
      "use_year": 2026,
      "label": "2026 Use Year",
      "start": "2026-06-01",
      "end": "2027-05-31",
      "banking_deadline": "2027-01-31",
      "banking_deadline_passed": false,
      "days_until_banking_deadline": 325,
      "point_expiration": "2027-05-31",
      "days_until_expiration": 445,
      "status": "upcoming"
    }
  ]
}
```

**`backend/engine/use_year.py`:** Add functions:
```python
def get_current_use_year(use_year_month: int, as_of: date = None) -> int:
    """Determine which use year is current as of a given date."""
    if as_of is None:
        as_of = date.today()
    # If we're past this year's UY start, current UY is this year
    # Otherwise it's last year's UY
    if as_of.month >= use_year_month:
        return as_of.year
    else:
        return as_of.year - 1

def get_use_year_status(use_year_month: int, use_year: int, as_of: date = None) -> str:
    """Return 'expired', 'active', or 'upcoming' for a use year."""
    if as_of is None:
        as_of = date.today()
    start = get_use_year_start(use_year_month, use_year)
    end = get_use_year_end(use_year_month, use_year)
    if as_of > end:
        return "expired"
    elif as_of >= start:
        return "active"
    else:
        return "upcoming"

def build_use_year_timeline(use_year_month: int, use_year: int, as_of: date = None) -> dict:
    """Build a complete timeline dict for a given use year."""
    if as_of is None:
        as_of = date.today()
    start = get_use_year_start(use_year_month, use_year)
    end = get_use_year_end(use_year_month, use_year)
    banking_deadline = get_banking_deadline(use_year_month, use_year)
    return {
        "use_year": use_year,
        "label": f"{use_year} Use Year",
        "start": start.isoformat(),
        "end": end.isoformat(),
        "banking_deadline": banking_deadline.isoformat(),
        "banking_deadline_passed": as_of > banking_deadline,
        "days_until_banking_deadline": (banking_deadline - as_of).days,
        "point_expiration": end.isoformat(),
        "days_until_expiration": (end - as_of).days,
        "status": get_use_year_status(use_year_month, use_year, as_of),
    }
```

**`tests/test_api_points.py`:**
- Create a contract, then POST point balances for current/banked/borrowed
- GET /api/contracts/{id}/points -> returns grouped balances with correct totals
- POST duplicate (same contract + use_year + allocation_type) -> 409
- PUT updates the points value
- DELETE removes the balance entry
- GET /api/contracts/{id}/timeline -> returns timeline with correct dates
- Test with June UY: verify banking deadline is January 31
- Test with December UY: verify banking deadline is July 31
- Test status: "active" for current UY, "upcoming" for next UY, "expired" for past UY

### 3. Contracts & Point Balances UI (React)

**File(s):**
- `frontend/src/pages/ContractsPage.tsx`
- `frontend/src/components/ContractCard.tsx`
- `frontend/src/components/ContractFormDialog.tsx`
- `frontend/src/components/PointBalanceForm.tsx`
- `frontend/src/components/UseYearTimeline.tsx`
- `frontend/src/components/EligibleResorts.tsx`
- `frontend/src/hooks/useContracts.ts`
- `frontend/src/hooks/usePoints.ts`
- `frontend/src/lib/api.ts` (extend with contract/point endpoints)

**Action:** Build the complete contracts management UI.

**`frontend/src/hooks/useContracts.ts`:** TanStack Query hooks:
```typescript
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import { api } from "../lib/api";

export function useContracts() {
  return useQuery({ queryKey: ["contracts"], queryFn: () => api.get("/contracts") });
}
export function useContract(id: number) {
  return useQuery({ queryKey: ["contracts", id], queryFn: () => api.get(`/contracts/${id}`) });
}
export function useCreateContract() { /* mutation with invalidation */ }
export function useUpdateContract() { /* mutation with invalidation */ }
export function useDeleteContract() { /* mutation with invalidation */ }
```

**`frontend/src/hooks/usePoints.ts`:** TanStack Query hooks for point balances and timeline:
```typescript
export function useContractPoints(contractId: number) {
  return useQuery({ queryKey: ["points", contractId], queryFn: () => api.get(`/contracts/${contractId}/points`) });
}
export function useContractTimeline(contractId: number) {
  return useQuery({ queryKey: ["timeline", contractId], queryFn: () => api.get(`/contracts/${contractId}/timeline`) });
}
export function useCreatePointBalance() { /* mutation */ }
export function useUpdatePointBalance() { /* mutation */ }
export function useDeletePointBalance() { /* mutation */ }
```

**`frontend/src/pages/ContractsPage.tsx`:** Replace placeholder. Shows:
1. Header with "My Contracts" title and "Add Contract" button
2. Grid of `ContractCard` components (responsive: 1 col mobile, 2 cols tablet, 3 cols desktop)
3. Empty state when no contracts exist: "No contracts yet. Add your first DVC contract to get started."

**`frontend/src/components/ContractCard.tsx`:** Card (using shadcn Card) showing:
- Resort name (human-readable from resorts data) and optional contract nickname
- Use year month (e.g., "June Use Year")
- Annual points (e.g., "160 points/year")
- Purchase type badge: "Resale" (amber) or "Direct" (green)
- Point balance summary: current year, banked, borrowed totals. Show individual allocation types.
- Use year timeline snippet (next banking deadline, days until)
- Edit and Delete buttons (delete requires confirmation dialog)
- Click to expand or navigate to detail view showing full timeline + eligible resorts

**`frontend/src/components/ContractFormDialog.tsx`:** Dialog (shadcn Dialog) for creating/editing contracts:
- Fields: Name (optional text), Home Resort (select dropdown populated from /api/resorts), Use Year Month (select with the 8 valid options showing month names), Annual Points (number input), Purchase Type (select: Resale/Direct)
- Form validation matching backend rules (resort must be valid, UY month must be valid, points > 0)
- On submit: POST or PUT to API, close dialog, invalidate queries
- For edit mode: pre-populate fields with existing contract data

**`frontend/src/components/PointBalanceForm.tsx`:** Inline form or dialog for entering/editing point balances per contract:
- Fields: Use Year (number input, default to current year), Allocation Type (select: Current/Banked/Borrowed/Holding), Points (number input)
- Shows existing balances in a small table grouped by use year
- Edit (pencil icon) and Delete (trash icon) on each row
- Add new entry button per use year

**`frontend/src/components/UseYearTimeline.tsx`:** Visual timeline for a contract's use year:
- Show current and next use year as horizontal bars or timeline segments
- Mark key dates: UY start, banking deadline, UY end/expiration
- Color-code: green for "banking window open", amber for "banking deadline approaching (<30 days)", red for "banking deadline passed"
- Show days until banking deadline and point expiration as text
- Use date-fns for formatting (e.g., "Jan 31, 2027", "in 325 days")

**`frontend/src/components/EligibleResorts.tsx`:** Display eligible resorts for a contract:
- List resort names with a check mark icon
- If resale with restricted resort: show prominent warning "Resale contract -- can only book at home resort"
- If resale with original resort: show "Can book at 14 original DVC resorts"
- If direct: show "Can book at all DVC resorts"
- Group resorts by location (Walt Disney World, Disneyland, Hawaii, etc.)

## Verification

1. **Contract CRUD via API:**
   ```bash
   # Create
   curl -X POST http://localhost:8000/api/contracts \
     -H "Content-Type: application/json" \
     -d '{"home_resort":"polynesian","use_year_month":6,"annual_points":160,"purchase_type":"resale","name":"Poly Contract"}'
   # Returns 201 with contract JSON

   # List
   curl http://localhost:8000/api/contracts
   # Returns list with eligible_resorts and use_year_timeline

   # Update
   curl -X PUT http://localhost:8000/api/contracts/1 \
     -H "Content-Type: application/json" \
     -d '{"annual_points":200}'
   # Returns updated contract

   # Delete
   curl -X DELETE http://localhost:8000/api/contracts/1
   # Returns 204
   ```

2. **Point balance management:**
   ```bash
   # Add balance
   curl -X POST http://localhost:8000/api/contracts/1/points \
     -H "Content-Type: application/json" \
     -d '{"use_year":2026,"allocation_type":"current","points":160}'
   # Returns 201

   # Get balances
   curl http://localhost:8000/api/contracts/1/points
   # Returns grouped balances with totals

   # Get timeline
   curl http://localhost:8000/api/contracts/1/timeline
   # Returns use year timeline with dates and statuses
   ```

3. **Eligibility logic:**
   ```bash
   curl http://localhost:8000/api/contracts  # Check eligible_resorts field
   # Resale @ polynesian -> 14 original resort slugs
   # Direct @ polynesian -> all 17 resort slugs
   # Resale @ riviera -> ["riviera"] only
   ```

4. **Frontend:**
   - Visit http://localhost:5173/contracts
   - Click "Add Contract" -- form dialog opens with resort dropdown, UY selector
   - Fill in: Polynesian, June UY, 160 points, Resale -- submit
   - Contract card appears with correct info, "Resale" badge in amber
   - Click to expand -- see eligible resorts (14 original), use year timeline
   - Enter point balances: 2026 Current 160, 2025 Banked 45
   - Point summary shows totals: 205 total across both years
   - Timeline shows banking deadline and status

5. **Tests:**
   ```bash
   pytest tests/test_eligibility.py tests/test_api_contracts.py tests/test_api_points.py -v
   # All pass
   ```

## Notes

- The point balance model uses individual rows per allocation type (current/banked/borrowed/holding) rather than a single row with multiple columns. This is more flexible and explicitly models the STATE.md requirement for holding account points.
- Borrowing limit is NOT enforced as a hard constraint in this plan. The API logs a warning but does not reject borrows > 100% of annual points. This is per STATE.md: "make borrowing percentage configurable" -- the configuration mechanism will be added in Phase 2 when the calculation engine needs it.
- The 409 Conflict on duplicate point balance (same contract + year + type) prevents accidental double-entry while keeping the API simple. The user should update an existing entry rather than creating a duplicate.
- The eligible_resorts computation is done at read time (not stored). This is correct because if a user changes purchase_type from resale to direct, eligibility should update immediately.
- The use year timeline is computed server-side using the engine functions. The frontend simply renders the pre-computed dates and statuses -- no DVC business logic in React, per the architecture anti-pattern guidance.
