# Plan 02-02: Reservation CRUD API + Point Availability API

**Phase:** 2 -- Calculations & Reservations
**Goal:** User can manage reservations through the API and query point availability for any target date, with reservation deductions reflected in availability calculations.
**Requirements:** TRIP-01, TRIP-03, TRIP-04, TRIP-05 (API layer), PNTS-04, PNTS-05, PNTS-06 (API layer)
**Depends on:** Plan 02-01 (Reservation model, availability engine)

## Context

Plan 02-01 created the Reservation model and the pure-function point availability engine. This plan wraps those in FastAPI endpoints: full CRUD for reservations and a point availability query endpoint.

Existing infrastructure this plan builds on:
- `backend/models/reservation.py` -- Reservation SQLAlchemy model (from 02-01)
- `backend/engine/availability.py` -- get_contract_availability, get_all_contracts_availability (from 02-01)
- `backend/api/schemas.py` -- Existing Pydantic schemas for contracts and point balances
- `backend/data/point_charts.py` -- calculate_stay_cost function for auto-calculating reservation point costs
- `backend/api/contracts.py` -- Pattern for CRUD endpoints with enriched responses
- `backend/api/points.py` -- Pattern for nested resource endpoints
- `tests/conftest.py` -- Test fixtures with in-memory SQLite

The reservation API follows the same patterns established in Phase 1:
- Nested under contracts: `POST /api/contracts/{id}/reservations` for creation
- Direct access for updates: `PUT /api/reservations/{id}`
- Pydantic schemas for validation
- Integration tests with dependency override

## Tasks

### 1. Reservation Pydantic schemas + CRUD API endpoints + tests

**File(s):**
- `backend/api/schemas.py` (extend)
- `backend/api/reservations.py` (new)
- `backend/main.py` (wire router)
- `tests/test_api_reservations.py` (new)

**Action:** Create the reservation management API.

**Add to `backend/api/schemas.py`:**
```python
from datetime import date as date_type

class ReservationCreate(BaseModel):
    resort: str = Field(..., min_length=1)
    room_key: str = Field(..., min_length=1)
    check_in: date_type
    check_out: date_type
    points_cost: int = Field(..., gt=0)
    status: str = Field("confirmed", pattern="^(confirmed|pending|cancelled)$")
    confirmation_number: Optional[str] = None
    notes: Optional[str] = None

    @field_validator("resort")
    @classmethod
    def validate_resort(cls, v):
        from backend.data.resorts import get_resort_slugs
        if v not in get_resort_slugs():
            raise ValueError(f"Invalid resort slug.")
        return v

    @field_validator("check_out")
    @classmethod
    def validate_check_out(cls, v, info):
        check_in = info.data.get("check_in")
        if check_in and v <= check_in:
            raise ValueError("check_out must be after check_in")
        if check_in and (v - check_in).days > 14:
            raise ValueError("Stay cannot exceed 14 nights")
        return v


class ReservationUpdate(BaseModel):
    resort: Optional[str] = None
    room_key: Optional[str] = None
    check_in: Optional[date_type] = None
    check_out: Optional[date_type] = None
    points_cost: Optional[int] = Field(None, gt=0)
    status: Optional[str] = Field(None, pattern="^(confirmed|pending|cancelled)$")
    confirmation_number: Optional[str] = None
    notes: Optional[str] = None

    @field_validator("resort")
    @classmethod
    def validate_resort(cls, v):
        if v is not None:
            from backend.data.resorts import get_resort_slugs
            if v not in get_resort_slugs():
                raise ValueError("Invalid resort slug.")
        return v


class ReservationResponse(BaseModel):
    id: int
    contract_id: int
    resort: str
    room_key: str
    check_in: date_type
    check_out: date_type
    points_cost: int
    status: str
    confirmation_number: Optional[str]
    notes: Optional[str]
    created_at: datetime
    updated_at: datetime

    model_config = {"from_attributes": True}
```

**`backend/api/reservations.py`:** Create the reservations router.

Endpoints:
- `GET /api/reservations` -- List all reservations across all contracts. Supports optional query params:
  - `?contract_id=1` -- filter by contract
  - `?status=confirmed` -- filter by status
  - `?upcoming=true` -- only future reservations (check_in >= today)
  Returns `list[ReservationResponse]` sorted by check_in date ascending.

- `GET /api/contracts/{contract_id}/reservations` -- List reservations for a specific contract. Returns `list[ReservationResponse]`.

- `GET /api/reservations/{id}` -- Get a single reservation. Returns `ReservationResponse` or 404.

- `POST /api/contracts/{contract_id}/reservations` -- Create a reservation for a contract.
  - Validates contract exists (404 if not)
  - Validates resort is in the contract's eligible resorts list (422 if not, with message explaining resale restriction)
  - Returns `ReservationResponse` with 201 status

- `PUT /api/reservations/{id}` -- Update a reservation. Accepts `ReservationUpdate` (partial). Returns `ReservationResponse`.

- `DELETE /api/reservations/{id}` -- Delete a reservation. Returns 204.

The eligibility check on POST is important -- a resale contract at Polynesian cannot create a reservation at Riviera. Use `get_eligible_resorts()` from the eligibility engine to validate.

**Wire into `backend/main.py`:** `app.include_router(reservations_router)`.

**`tests/test_api_reservations.py`:** Integration tests using httpx AsyncClient:

**CRUD tests:**
- POST reservation with valid data -> 201, returns reservation with all fields
- POST reservation for non-existent contract -> 404
- POST reservation at ineligible resort (resale contract, restricted resort) -> 422 with eligibility error
- POST reservation with check_out before check_in -> 422
- POST reservation exceeding 14 nights -> 422
- GET /api/reservations -> returns list of all reservations
- GET /api/reservations?contract_id=1 -> filtered by contract
- GET /api/reservations?status=confirmed -> filtered by status
- GET /api/reservations?upcoming=true -> only future reservations
- GET /api/contracts/{id}/reservations -> returns contract's reservations
- GET /api/reservations/{id} -> returns single reservation
- PUT updates specified fields only
- PUT status to "cancelled" -> updates status
- DELETE -> 204, subsequent GET returns 404

**Edge cases:**
- Create reservation at home resort for restricted resale contract -> 201 (allowed)
- Create reservation at original-14 resort for original resale contract -> 201 (allowed)
- Multiple reservations for same contract -> all returned in list

### 2. Point availability API endpoint + tests

**File(s):**
- `backend/api/availability.py` (new)
- `backend/main.py` (wire router)
- `tests/test_api_availability.py` (new)

**Action:** Create the point availability query endpoint.

**`backend/api/availability.py`:** Create the availability router.

```python
from fastapi import APIRouter, Depends, Query
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from datetime import date

from backend.db.database import get_db
from backend.models.contract import Contract
from backend.models.point_balance import PointBalance
from backend.models.reservation import Reservation
from backend.engine.availability import get_all_contracts_availability

router = APIRouter(tags=["availability"])


@router.get("/api/availability")
async def get_availability(
    target_date: date = Query(..., description="Target date (YYYY-MM-DD) to check availability for"),
    db: AsyncSession = Depends(get_db),
):
    """
    Calculate point availability across all contracts for a target date.

    Returns per-contract breakdown showing:
    - Which use year is active
    - Point balances by allocation type (current, banked, borrowed, holding)
    - Points committed to reservations in that use year
    - Net available points
    - Banking deadline status

    Plus a summary with grand totals across all contracts.
    """
    # Load all contracts
    result = await db.execute(select(Contract))
    contracts = result.scalars().all()

    # Load all point balances
    result = await db.execute(select(PointBalance))
    all_balances = result.scalars().all()

    # Load all non-cancelled reservations
    result = await db.execute(
        select(Reservation).where(Reservation.status != "cancelled")
    )
    all_reservations = result.scalars().all()

    # Convert ORM objects to dicts for the pure-function engine
    contracts_data = [
        {
            "id": c.id,
            "name": c.name,
            "home_resort": c.home_resort,
            "use_year_month": c.use_year_month,
            "annual_points": c.annual_points,
            "purchase_type": c.purchase_type,
        }
        for c in contracts
    ]

    balances_data = [
        {
            "contract_id": b.contract_id,
            "use_year": b.use_year,
            "allocation_type": b.allocation_type,
            "points": b.points,
        }
        for b in all_balances
    ]

    reservations_data = [
        {
            "contract_id": r.contract_id,
            "check_in": r.check_in,
            "points_cost": r.points_cost,
            "status": r.status,
        }
        for r in all_reservations
    ]

    return get_all_contracts_availability(
        contracts=contracts_data,
        point_balances=balances_data,
        reservations=reservations_data,
        target_date=target_date,
    )
```

Also add to the schemas:
```python
class AvailabilityContractResult(BaseModel):
    contract_id: int
    contract_name: str
    home_resort: str
    annual_points: int
    use_year: int
    use_year_start: str
    use_year_end: str
    use_year_status: str
    banking_deadline: str
    banking_deadline_passed: bool
    days_until_banking_deadline: int
    days_until_expiration: int
    balances: dict  # allocation_type -> points
    total_points: int
    committed_points: int
    committed_reservation_count: int
    available_points: int


class AvailabilitySummary(BaseModel):
    total_contracts: int
    total_points: int
    total_committed: int
    total_available: int


class AvailabilityResponse(BaseModel):
    target_date: str
    contracts: list[AvailabilityContractResult]
    summary: AvailabilitySummary
```

**Wire into `backend/main.py`:** `app.include_router(availability_router)`.

**`tests/test_api_availability.py`:** Integration tests:

**Basic availability tests:**
- No contracts in DB -> returns empty contracts list, summary all zeros
- One contract with point balances, no reservations -> available = total points
- One contract with point balances and a reservation -> available = total - reservation cost
- Missing target_date param -> 422

**Multi-contract tests:**
- Two contracts with different UY months, same target date -> correct per-contract breakdown
- Summary totals match sum of individual contract results

**Reservation deduction integration:**
- Create contract + point balances + reservation via API
- Query availability -> reservation correctly deducted
- Cancel the reservation (PUT status=cancelled) -> re-query availability -> reservation no longer deducted
- Multiple reservations in same UY -> all deducted

**Use year edge cases:**
- Target date right at UY boundary -> correct UY selected
- Contract with points in multiple UYs -> only active UY's points counted for target date

**End-to-end scenario:**
- Create 2 contracts (Polynesian June UY, Riviera December UY)
- Add point balances for each (current + banked)
- Add reservations for each
- Query availability for a date -> verify per-contract breakdown and grand total

## Verification

1. **Reservation API works end-to-end:**
   ```bash
   # Create a contract first
   curl -X POST http://localhost:8000/api/contracts \
     -H "Content-Type: application/json" \
     -d '{"home_resort":"polynesian","use_year_month":6,"annual_points":160,"purchase_type":"resale"}'

   # Create a reservation
   curl -X POST http://localhost:8000/api/contracts/1/reservations \
     -H "Content-Type: application/json" \
     -d '{"resort":"polynesian","room_key":"deluxe_studio_standard","check_in":"2026-03-15","check_out":"2026-03-20","points_cost":85}'
   # Returns 201

   # List reservations
   curl http://localhost:8000/api/reservations
   # Returns list with the reservation

   # Try ineligible resort
   curl -X POST http://localhost:8000/api/contracts/1/reservations \
     -H "Content-Type: application/json" \
     -d '{"resort":"riviera","room_key":"deluxe_studio_standard","check_in":"2026-03-15","check_out":"2026-03-20","points_cost":90}'
   # Returns 422 -- resale contract can't book Riviera
   ```

2. **Availability API works:**
   ```bash
   # Add point balances
   curl -X POST http://localhost:8000/api/contracts/1/points \
     -H "Content-Type: application/json" \
     -d '{"use_year":2025,"allocation_type":"current","points":160}'

   # Query availability
   curl "http://localhost:8000/api/availability?target_date=2026-03-15"
   # Returns: contract has 160 total, 85 committed, 75 available
   ```

3. **All tests pass:**
   ```bash
   pytest tests/ -v
   # All existing tests pass
   # test_api_reservations.py: all CRUD + edge case tests pass
   # test_api_availability.py: all availability query tests pass
   ```

## Notes

- The reservation POST endpoint validates resort eligibility against the contract's purchase type. This prevents creating reservations at resorts the contract can't actually book at, catching a common user error early.
- The availability endpoint loads all contracts, balances, and reservations in 3 queries. For a single-user app with a handful of contracts, this is efficient enough. No need for complex JOINs.
- The availability response includes banking deadline info per contract so the frontend can show urgency indicators without a separate API call.
- The `upcoming=true` filter on GET /api/reservations uses check_in >= date.today() to show only future reservations. This is useful for the dashboard view in Phase 3.
- Point cost auto-calculation from point charts is NOT included in the reservation creation flow in this plan. The user enters the point cost manually. The frontend in Plan 02-03 will integrate the existing StayCostCalculator to help the user determine the cost before entering it.
