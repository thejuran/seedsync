# Plan 02-01: Reservation Model + Point Availability Engine

**Phase:** 2 -- Calculations & Reservations
**Goal:** Create the Reservation data model and build the pure-function point availability engine that computes per-contract point availability for any target date, with reservation deductions included.
**Requirements:** TRIP-03 (data model), TRIP-04 (data model), TRIP-05 (engine), PNTS-04 (engine), PNTS-05 (engine), PNTS-06 (engine)
**Depends on:** Phase 1 (all plans complete -- Contract, PointBalance models, use year engine, eligibility engine, point chart data)

## Context

Phase 1 established the data foundation: Contract and PointBalance models, use year date math, eligibility resolver, and point chart cost calculator. Phase 2 builds the calculation and reservation layer on top.

This plan creates two things:

1. **Reservation model** -- A SQLAlchemy model for tracking DVC resort reservations, linked to contracts. Each reservation has a resort, room type, check-in/out dates, point cost, and status. This is the data model that TRIP-03/04 need, with CRUD endpoints coming in Plan 02-02.

2. **Point availability engine** -- Pure functions that answer: "For a given target date, how many points does each contract have available?" The engine determines which use year is active for each contract on the target date, sums the point buckets (current, banked, borrowed, holding), deducts points committed to reservations in that use year, and returns a per-contract breakdown plus cross-contract total.

Key domain rules encoded in this plan:
- **Use year determines point pool:** Points are grouped by use year. For target date March 2026 with a June use year, the 2025 use year is active (June 2025 - May 2026). All PointBalance entries for use_year=2025 contribute to the pool.
- **Reservation deductions:** Reservations whose check-in date falls within a use year's range deduct from that use year's point pool. Cancelled reservations are excluded.
- **Banking/expiration awareness:** The engine reports whether the banking deadline has passed and when points expire, enabling the UI to show urgency indicators.
- **Borrowing:** Borrowed points appear as PointBalance entries with allocation_type="borrowed" for the use year they're borrowed INTO, so they're automatically included in the pool.

Existing code this plan builds on:
- `backend/models/contract.py` -- Contract model with home_resort, use_year_month, annual_points
- `backend/models/point_balance.py` -- PointBalance model with use_year, allocation_type, points
- `backend/engine/use_year.py` -- get_use_year_start, get_use_year_end, get_banking_deadline, get_current_use_year, build_use_year_timeline
- `backend/engine/eligibility.py` -- get_eligible_resorts
- `backend/data/point_charts.py` -- calculate_stay_cost (used for trip cost lookup validation)

## Tasks

### 1. Reservation SQLAlchemy model + Alembic migration + model tests

**File(s):**
- `backend/models/reservation.py`
- `backend/models/__init__.py` (update imports)
- `backend/db/migrations/versions/` (new migration)
- `tests/test_models.py` (extend with reservation tests)

**Action:** Create the Reservation model and database migration.

**`backend/models/reservation.py`:**
```python
from sqlalchemy import Column, Integer, String, Date, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from backend.db.database import Base
import enum
from datetime import datetime


class ReservationStatus(str, enum.Enum):
    CONFIRMED = "confirmed"
    PENDING = "pending"
    CANCELLED = "cancelled"


class Reservation(Base):
    __tablename__ = "reservations"

    id = Column(Integer, primary_key=True, autoincrement=True)
    contract_id = Column(Integer, ForeignKey("contracts.id"), nullable=False)
    resort = Column(String, nullable=False)  # resort slug e.g. "polynesian"
    room_key = Column(String, nullable=False)  # composite key e.g. "deluxe_studio_lake"
    check_in = Column(Date, nullable=False)
    check_out = Column(Date, nullable=False)
    points_cost = Column(Integer, nullable=False)  # total points for this reservation
    status = Column(String, nullable=False, default=ReservationStatus.CONFIRMED.value)
    confirmation_number = Column(String, nullable=True)
    notes = Column(String, nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

    contract = relationship("Contract", back_populates="reservations")
```

**Update `backend/models/contract.py`:** Add the reservations relationship to Contract:
```python
# Add to Contract class:
reservations = relationship("Reservation", back_populates="contract", cascade="all, delete-orphan")
```

**Update `backend/models/__init__.py`:** Add Reservation and ReservationStatus imports.

**Alembic migration:** Run `alembic revision --autogenerate -m "add_reservations_table"` to create the migration. Verify it creates the `reservations` table with all columns and the foreign key to `contracts`. Apply with `alembic upgrade head`.

**Tests to add to `tests/test_models.py`:**
- Create a Reservation linked to a Contract: verify all fields persist
- Test contract-reservation relationship (contract.reservations returns the reservation)
- Test cascade delete (deleting contract removes its reservations)
- Test ReservationStatus enum values
- Create multiple reservations for one contract: verify list loads correctly

### 2. Point availability engine + comprehensive unit tests

**File(s):**
- `backend/engine/availability.py` (new)
- `backend/engine/__init__.py` (update)
- `tests/test_availability.py` (new)

**Action:** Build the pure-function point availability calculator.

**`backend/engine/availability.py`:** Create the core availability calculation functions.

```python
from datetime import date
from backend.engine.use_year import (
    get_use_year_start,
    get_use_year_end,
    get_banking_deadline,
    get_current_use_year,
    get_use_year_status,
)


def get_contract_availability(
    contract_id: int,
    use_year_month: int,
    annual_points: int,
    point_balances: list[dict],
    reservations: list[dict],
    target_date: date,
) -> dict:
    """
    Calculate point availability for a single contract on a target date.

    Args:
        contract_id: The contract ID
        use_year_month: The contract's use year month (2,3,4,...,12)
        annual_points: The contract's annual point allocation
        point_balances: List of dicts with keys: use_year, allocation_type, points
        reservations: List of dicts with keys: check_in (date), points_cost (int), status (str)
        target_date: The date to calculate availability for

    Returns:
        Dict with per-use-year breakdown, committed points, and available total.
    """
    # Determine which use year is active on the target date
    current_uy = get_current_use_year(use_year_month, as_of=target_date)

    uy_start = get_use_year_start(use_year_month, current_uy)
    uy_end = get_use_year_end(use_year_month, current_uy)
    banking_deadline = get_banking_deadline(use_year_month, current_uy)

    # Gather point balances for this use year
    balances_by_type = {}
    total_points = 0
    for b in point_balances:
        if b["use_year"] == current_uy:
            alloc_type = b["allocation_type"]
            pts = b["points"]
            balances_by_type[alloc_type] = balances_by_type.get(alloc_type, 0) + pts
            total_points += pts

    # Sum reservations committed against this use year
    # A reservation deducts from a use year if its check_in falls within the UY range
    committed_points = 0
    committed_reservations = []
    for r in reservations:
        check_in = r["check_in"] if isinstance(r["check_in"], date) else date.fromisoformat(r["check_in"])
        if r.get("status", "confirmed") == "cancelled":
            continue
        if uy_start <= check_in <= uy_end:
            committed_points += r["points_cost"]
            committed_reservations.append(r)

    available_points = max(0, total_points - committed_points)

    return {
        "contract_id": contract_id,
        "use_year": current_uy,
        "use_year_start": uy_start.isoformat(),
        "use_year_end": uy_end.isoformat(),
        "use_year_status": get_use_year_status(use_year_month, current_uy, as_of=target_date),
        "banking_deadline": banking_deadline.isoformat(),
        "banking_deadline_passed": target_date > banking_deadline,
        "days_until_banking_deadline": (banking_deadline - target_date).days,
        "days_until_expiration": (uy_end - target_date).days,
        "balances": balances_by_type,
        "total_points": total_points,
        "committed_points": committed_points,
        "committed_reservation_count": len(committed_reservations),
        "available_points": available_points,
    }


def get_all_contracts_availability(
    contracts: list[dict],
    point_balances: list[dict],
    reservations: list[dict],
    target_date: date,
) -> dict:
    """
    Calculate point availability across ALL contracts for a target date.

    Args:
        contracts: List of dicts with keys: id, use_year_month, annual_points, home_resort, purchase_type, name
        point_balances: All point balances across all contracts
        reservations: All reservations across all contracts
        target_date: The date to calculate availability for

    Returns:
        Dict with per-contract breakdowns and grand total.
    """
    contract_results = []
    grand_total_points = 0
    grand_committed = 0
    grand_available = 0

    for c in contracts:
        # Filter balances and reservations for this contract
        c_balances = [b for b in point_balances if b["contract_id"] == c["id"]]
        c_reservations = [r for r in reservations if r["contract_id"] == c["id"]]

        result = get_contract_availability(
            contract_id=c["id"],
            use_year_month=c["use_year_month"],
            annual_points=c["annual_points"],
            point_balances=c_balances,
            reservations=c_reservations,
            target_date=target_date,
        )

        # Enrich with contract metadata
        result["contract_name"] = c.get("name") or c.get("home_resort", "Unknown")
        result["home_resort"] = c.get("home_resort")
        result["annual_points"] = c["annual_points"]

        contract_results.append(result)
        grand_total_points += result["total_points"]
        grand_committed += result["committed_points"]
        grand_available += result["available_points"]

    return {
        "target_date": target_date.isoformat(),
        "contracts": contract_results,
        "summary": {
            "total_contracts": len(contracts),
            "total_points": grand_total_points,
            "total_committed": grand_committed,
            "total_available": grand_available,
        },
    }
```

The functions take plain dicts (not ORM objects) so they are pure functions with no database dependency, making them independently testable. The API layer in Plan 02-02 will convert ORM objects to dicts before calling these functions.

**`tests/test_availability.py`:** Comprehensive unit tests:

**Basic availability tests:**
- Single contract, no reservations: available = sum of all balances for active use year
- Single contract, one reservation in UY: available = total - reservation points
- Single contract, cancelled reservation: cancelled reservation NOT deducted
- Single contract, no point balances for target date's UY: available = 0

**Multi-allocation tests:**
- Contract with current (160) + banked (45) for same UY: total = 205
- Contract with current (160) + borrowed (50) for same UY: total = 210
- Contract with all 4 types: current + banked + borrowed + holding = correct total

**Use year boundary tests:**
- June UY, target date = March 2026: active UY = 2025 (June 2025 - May 2026)
- June UY, target date = July 2026: active UY = 2026 (June 2026 - May 2027)
- December UY, target date = January 2026: active UY = 2025 (Dec 2025 - Nov 2026)
- February UY, target date = January 2026: active UY = 2025 (Feb 2025 - Jan 2026)

**Reservation deduction tests:**
- Reservation check_in within UY: deducted
- Reservation check_in outside UY (different year): NOT deducted
- Multiple reservations: all deducted from same UY
- Deductions cannot produce negative (available = 0 minimum)
- Reservation at UY boundary (check_in = last day of UY): deducted
- Reservation at UY start (check_in = first day of UY): deducted

**Multi-contract tests:**
- Two contracts with different use year months: correct per-contract breakdown
- Grand total = sum of all contract available points
- Summary counts match

**Banking deadline tests:**
- Target date before banking deadline: banking_deadline_passed = False
- Target date after banking deadline: banking_deadline_passed = True
- Correct days_until_banking_deadline (positive = future, negative = past)

## Verification

1. **Alembic migration applies cleanly:**
   ```bash
   alembic upgrade head  # adds reservations table
   alembic downgrade -1  # cleanly removes it
   alembic upgrade head  # re-apply
   ```

2. **All tests pass:**
   ```bash
   pytest tests/ -v
   # Existing 89 tests still pass
   # New model tests pass (reservation CRUD, relationships, cascade delete)
   # New availability engine tests pass (all scenarios above)
   ```

3. **Model relationships work:**
   - Contract.reservations returns linked reservations
   - Contract.point_balances still works (unchanged)
   - Deleting a contract cascade-deletes its reservations

## Notes

- The availability engine uses plain dicts as inputs, not ORM models. This is intentional -- pure functions with no I/O dependencies are easier to test and reason about.
- Reservation `status` defaults to "confirmed". Only non-cancelled reservations are counted in availability calculations.
- The `room_key` field on Reservation uses the same composite key format as point charts (e.g., "deluxe_studio_lake"). This enables cross-referencing with point chart data.
- The engine does NOT try to determine which specific point bucket (current vs. banked) a reservation should deduct from. It deducts from the total pool for the use year. This matches how DVC actually works -- Disney tracks the total, not which bucket each reservation draws from.
- Cross-contract point pooling is NOT modeled in this plan per STATE.md gap: "trip cost calculator should flag when a booking would require cross-UY pooling." A single contract's reservations deduct from that contract's points only.
