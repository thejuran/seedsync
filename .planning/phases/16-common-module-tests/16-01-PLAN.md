---
phase: 16-common-module-tests
plan: 01
type: execute
wave: 1
depends_on: ["15-01"]
files_modified:
  - src/python/tests/unittests/test_common/test_constants.py
  - src/python/tests/unittests/test_common/test_context.py
  - src/python/tests/unittests/test_common/test_error.py
  - src/python/tests/unittests/test_common/test_localization.py
  - src/python/tests/unittests/test_common/test_types.py
autonomous: true

must_haves:
  truths:
    - "All 5 common modules (constants, context, error, localization, types) have dedicated test files"
    - "Every public constant in Constants class has a regression test verifying its value"
    - "Args default values and as_dict() serialization are tested including None handling"
    - "Context constructor, create_child_context shallow copy behavior, and print_to_log are tested"
    - "AppError/ServiceExit/ServiceRestart inheritance chain is tested with raise/catch semantics"
    - "All Localization.Error strings are tested including format placeholder substitution"
    - "overrides decorator validates both success (valid override) and failure (non-class, non-existent method) cases"
    - "All 721+ existing tests still pass with zero regressions"
  artifacts:
    - path: "src/python/tests/unittests/test_common/test_constants.py"
      provides: "Regression tests for all Constants class attributes"
      contains: "class TestConstants"
    - path: "src/python/tests/unittests/test_common/test_context.py"
      provides: "Tests for Args and Context classes"
      contains: "class TestArgs"
    - path: "src/python/tests/unittests/test_common/test_error.py"
      provides: "Tests for exception hierarchy"
      contains: "class TestAppError"
    - path: "src/python/tests/unittests/test_common/test_localization.py"
      provides: "Tests for localization strings and format placeholders"
      contains: "class TestLocalizationError"
    - path: "src/python/tests/unittests/test_common/test_types.py"
      provides: "Tests for @overrides decorator positive and negative cases"
      contains: "class TestOverrides"
  key_links:
    - from: "src/python/tests/unittests/test_common/test_constants.py"
      to: "common.constants.Constants"
      via: "from common import Constants"
      pattern: "from common import Constants"
    - from: "src/python/tests/unittests/test_common/test_context.py"
      to: "common.context.Args, common.context.Context"
      via: "from common import Context, Args"
      pattern: "from common import Context, Args"
    - from: "src/python/tests/unittests/test_common/test_error.py"
      to: "common.error.AppError/ServiceExit/ServiceRestart"
      via: "from common import AppError, ServiceExit, ServiceRestart"
      pattern: "from common import AppError, ServiceExit, ServiceRestart"
    - from: "src/python/tests/unittests/test_common/test_localization.py"
      to: "common.localization.Localization"
      via: "from common import Localization"
      pattern: "from common import Localization"
    - from: "src/python/tests/unittests/test_common/test_types.py"
      to: "common.types.overrides"
      via: "from common import overrides"
      pattern: "from common import overrides"
---

<objective>
Create unit tests for all 5 untested common module files: constants.py, context.py, error.py, localization.py, and types.py.

Purpose: These 5 modules form the shared foundation of the SeedSync backend. Testing them establishes a regression safety net for constants, error hierarchy, context management, localization strings, and the @overrides decorator used in 30+ locations across the codebase.

Output: 5 new test files in src/python/tests/unittests/test_common/ adding ~40 test methods with ~70 assertions, covering all public APIs of the 5 modules.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/milestones/v1.5-ROADMAP.md
@.planning/STATE.md
@.planning/phases/16-common-module-tests/16-RESEARCH.md
@.planning/phases/15-coverage-tooling-shared-fixtures/15-01-SUMMARY.md
@src/python/common/constants.py
@src/python/common/context.py
@src/python/common/error.py
@src/python/common/localization.py
@src/python/common/types.py
@src/python/common/__init__.py
@src/python/tests/unittests/test_common/test_persist.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test_constants.py, test_error.py, and test_localization.py</name>
  <files>
    src/python/tests/unittests/test_common/test_constants.py
    src/python/tests/unittests/test_common/test_error.py
    src/python/tests/unittests/test_common/test_localization.py
  </files>
  <action>
  Create three test files for the simplest common modules. All files follow the project convention:
  copyright header, unittest.TestCase classes, `from common import ...` imports.

  **A. Create test_constants.py** with class `TestConstants(unittest.TestCase)`:

  ```python
  import unittest
  from common import Constants
  ```

  Test methods (one per constant, verifying exact value and type):
  - `test_service_name` -- assertEqual("seedsync", Constants.SERVICE_NAME); assertIsInstance str
  - `test_main_thread_sleep_interval` -- assertEqual(0.5, Constants.MAIN_THREAD_SLEEP_INTERVAL_IN_SECS); assertIsInstance float
  - `test_max_log_size_in_bytes` -- assertEqual(10 * 1024 * 1024, Constants.MAX_LOG_SIZE_IN_BYTES); assertEqual(10485760, Constants.MAX_LOG_SIZE_IN_BYTES); assertIsInstance int
  - `test_log_backup_count` -- assertEqual(10, Constants.LOG_BACKUP_COUNT); assertIsInstance int
  - `test_web_access_log_name` -- assertEqual("web_access", Constants.WEB_ACCESS_LOG_NAME); assertIsInstance str
  - `test_min_persist_to_file_interval` -- assertEqual(30, Constants.MIN_PERSIST_TO_FILE_INTERVAL_IN_SECS); assertIsInstance int
  - `test_json_pretty_print_indent` -- assertEqual(4, Constants.JSON_PRETTY_PRINT_INDENT); assertIsInstance int
  - `test_lftp_temp_file_suffix` -- assertEqual(".lftp", Constants.LFTP_TEMP_FILE_SUFFIX); assertIsInstance str
  - `test_constants_values_are_positive` -- for numeric constants, assertTrue(val > 0) for MAIN_THREAD_SLEEP_INTERVAL_IN_SECS, MAX_LOG_SIZE_IN_BYTES, LOG_BACKUP_COUNT, MIN_PERSIST_TO_FILE_INTERVAL_IN_SECS, JSON_PRETTY_PRINT_INDENT

  **B. Create test_error.py** with three classes:

  ```python
  import unittest
  from common import AppError, ServiceExit, ServiceRestart
  ```

  Class `TestAppError(unittest.TestCase)`:
  - `test_is_exception_subclass` -- assertTrue(issubclass(AppError, Exception))
  - `test_can_be_raised_and_caught` -- with self.assertRaises(AppError): raise AppError("test")
  - `test_message` -- try/except, assertEqual("test message", str(e))

  Class `TestServiceExit(unittest.TestCase)`:
  - `test_is_app_error_subclass` -- assertTrue(issubclass(ServiceExit, AppError))
  - `test_is_exception_subclass` -- assertTrue(issubclass(ServiceExit, Exception))
  - `test_caught_by_app_error_handler` -- with self.assertRaises(AppError): raise ServiceExit("exit")
  - `test_caught_by_exception_handler` -- with self.assertRaises(Exception): raise ServiceExit("exit")
  - `test_is_not_service_restart` -- assertFalse(issubclass(ServiceExit, ServiceRestart))

  Class `TestServiceRestart(unittest.TestCase)`:
  - `test_is_app_error_subclass` -- assertTrue(issubclass(ServiceRestart, AppError))
  - `test_is_exception_subclass` -- assertTrue(issubclass(ServiceRestart, Exception))
  - `test_caught_by_app_error_handler` -- with self.assertRaises(AppError): raise ServiceRestart("restart")
  - `test_is_not_service_exit` -- assertFalse(issubclass(ServiceRestart, ServiceExit))
  - `test_message_preserved` -- try/except, assertEqual("restart requested", str(e))

  **C. Create test_localization.py** with class `TestLocalizationError(unittest.TestCase)`:

  ```python
  import unittest
  from common import Localization
  ```

  Test methods:
  - `test_missing_file_string_exists` -- assertIsNotNone(Localization.Error.MISSING_FILE)
  - `test_missing_file_format` -- assertEqual("The file '/tmp/foo' doesn't exist.", Localization.Error.MISSING_FILE.format("/tmp/foo"))
  - `test_remote_server_scan_string_exists` -- assertIsNotNone(Localization.Error.REMOTE_SERVER_SCAN)
  - `test_remote_server_scan_format` -- assertEqual("An error occurred while scanning the remote server: 'connection refused'.", Localization.Error.REMOTE_SERVER_SCAN.format("connection refused"))
  - `test_remote_server_install_string_exists` -- assertIsNotNone(Localization.Error.REMOTE_SERVER_INSTALL)
  - `test_remote_server_install_format` -- assertEqual("An error occurred while installing scanner script to remote server: 'permission denied'.", Localization.Error.REMOTE_SERVER_INSTALL.format("permission denied"))
  - `test_local_server_scan_string_exists` -- assertIsNotNone(Localization.Error.LOCAL_SERVER_SCAN); assertNotIn("{}", Localization.Error.LOCAL_SERVER_SCAN) (no placeholder)
  - `test_settings_incomplete_string_exists` -- assertIsNotNone(Localization.Error.SETTINGS_INCOMPLETE); assertNotIn("{}", Localization.Error.SETTINGS_INCOMPLETE) (no placeholder)
  - `test_all_strings_are_str_type` -- assertIsInstance for each of the 5 strings
  </action>
  <verify>
  Run from src/python/:
  - `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_common/test_constants.py tests/unittests/test_common/test_error.py tests/unittests/test_common/test_localization.py -v`
  All tests must pass. Expected: ~28 test methods, 0 failures.
  </verify>
  <done>
  test_constants.py has 9 test methods covering all 8 Constants class attributes (values, types, positivity).
  test_error.py has 12 test methods across 3 classes covering exception hierarchy, inheritance, catch semantics, and message preservation.
  test_localization.py has 9 test methods covering all 5 Localization.Error strings (existence, format substitution, type, placeholder presence/absence).
  All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test_context.py and test_types.py, run full regression</name>
  <files>
    src/python/tests/unittests/test_common/test_context.py
    src/python/tests/unittests/test_common/test_types.py
  </files>
  <action>
  Create the two remaining test files. These require slightly more setup (MagicMock for Context, helper classes for overrides).

  **A. Create test_context.py** with two classes:

  ```python
  import unittest
  import logging
  import collections
  from unittest.mock import MagicMock
  from common import Context, Args
  ```

  Class `TestArgs(unittest.TestCase)`:
  - `test_default_values_are_none` -- args = Args(); assertIsNone for local_path_to_scanfs, html_path, debug, exit
  - `test_as_dict_returns_ordered_dict` -- args = Args(); assertIsInstance(args.as_dict(), collections.OrderedDict)
  - `test_as_dict_key_order` -- args = Args(); assertEqual(list(args.as_dict().keys()), ["local_path_to_scanfs", "html_path", "debug", "exit"])
  - `test_as_dict_converts_values_to_strings` -- args = Args(); args.local_path_to_scanfs = "/path"; args.html_path = "/html"; args.debug = True; args.exit = False; dct = args.as_dict(); assertEqual("/path", dct["local_path_to_scanfs"]); assertEqual("/html", dct["html_path"]); assertEqual("True", dct["debug"]); assertEqual("False", dct["exit"])
  - `test_as_dict_none_values_become_none_string` -- args = Args(); dct = args.as_dict(); assertEqual("None", dct["local_path_to_scanfs"]); assertEqual("None", dct["debug"])

  Class `TestContext(unittest.TestCase)`:

  In setUp (use @overrides(unittest.TestCase) per project convention):
  ```python
  from common import overrides
  @overrides(unittest.TestCase)
  def setUp(self):
      self.logger = logging.getLogger("TestContext")
      self.web_access_logger = logging.getLogger("TestContext.web")
      self.config = MagicMock()
      self.args = Args()
      self.status = MagicMock()
      self.context = Context(self.logger, self.web_access_logger,
                             self.config, self.args, self.status)
  ```

  Test methods:
  - `test_constructor_stores_logger` -- assertIs(self.logger, self.context.logger)
  - `test_constructor_stores_web_access_logger` -- assertIs(self.web_access_logger, self.context.web_access_logger)
  - `test_constructor_stores_config` -- assertIs(self.config, self.context.config)
  - `test_constructor_stores_args` -- assertIs(self.args, self.context.args)
  - `test_constructor_stores_status` -- assertIs(self.status, self.context.status)
  - `test_create_child_context_returns_new_object` -- child = self.context.create_child_context("child"); assertIsNot(self.context, child)
  - `test_create_child_context_has_child_logger` -- child = self.context.create_child_context("child"); assertIsNot(self.context.logger, child.logger); assertEqual("TestContext.child", child.logger.name)
  - `test_create_child_context_shares_config` -- child = self.context.create_child_context("child"); assertIs(self.context.config, child.config)
  - `test_create_child_context_shares_args` -- child = self.context.create_child_context("child"); assertIs(self.context.args, child.args)
  - `test_create_child_context_shares_status` -- child = self.context.create_child_context("child"); assertIs(self.context.status, child.status)
  - `test_create_child_context_shares_web_access_logger` -- child = self.context.create_child_context("child"); assertIs(self.context.web_access_logger, child.web_access_logger)
  - `test_print_to_log_calls_logger_debug` -- Set self.config.as_dict.return_value = {"Section": {"key": "value"}}; self.args.local_path_to_scanfs = "/path"; self.args.html_path = "/html"; self.args.debug = False; self.args.exit = False; Use a real logger with MagicMock handler or just use MagicMock logger: replace self.context.logger with MagicMock(); call self.context.print_to_log(); assertTrue(self.context.logger.debug.called); assert call count >= 3 (at least "Config:", one config line, "Args:")

  **B. Create test_types.py** with class `TestOverrides(unittest.TestCase)`:

  ```python
  import unittest
  from common import overrides
  ```

  Define helper classes INSIDE the test file (before the test class):
  ```python
  class _Base:
      def existing_method(self):
          pass

  class _GrandParent:
      def inherited_method(self):
          pass

  class _Parent(_GrandParent):
      pass
  ```

  Test methods:
  - `test_valid_override_succeeds` -- Define class with @overrides(_Base) on existing_method; no exception raised; verify method is callable and returns correctly
  - `test_decorated_method_still_callable` -- Create instance of child class with @overrides(_Base) existing_method that returns "result"; assertEqual("result", instance.existing_method())
  - `test_works_with_unittest_testcase` -- @overrides(unittest.TestCase) on a setUp method of a dummy class; no exception
  - `test_works_with_inherited_method` -- @overrides(_Parent) on inherited_method (exists via _GrandParent); no exception
  - `test_non_class_raises_assertion_error` -- with self.assertRaises(AssertionError) as cm: @overrides("not_a_class") def some_method(self): pass; assertIn("Overrides parameter must be a class type", str(cm.exception))
  - `test_non_existent_method_raises_assertion_error` -- with self.assertRaises(AssertionError) as cm: @overrides(_Base) def nonexistent_method(self): pass; assertIn("Method does not override super class", str(cm.exception))
  - `test_integer_raises_assertion_error` -- with self.assertRaises(AssertionError): @overrides(42) def method(self): pass
  - `test_function_raises_assertion_error` -- def some_func(): pass; with self.assertRaises(AssertionError): @overrides(some_func) def method(self): pass
  </action>
  <verify>
  Run from src/python/:

  1. Run only the new test files:
  `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_common/test_context.py tests/unittests/test_common/test_types.py -v`
  All tests must pass. Expected: ~18 test methods, 0 failures.

  2. Run ALL tests to confirm zero regressions:
  `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest -q 2>&1 | tail -5`
  Must show 721+ tests with no NEW failures (pre-existing failures from missing lftp/ssh are acceptable).

  3. Run only the 5 new test files together to get combined count:
  `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_common/test_constants.py tests/unittests/test_common/test_context.py tests/unittests/test_common/test_error.py tests/unittests/test_common/test_localization.py tests/unittests/test_common/test_types.py -v`
  Expected: ~40+ test methods, all passing.
  </verify>
  <done>
  test_context.py has TestArgs (5 methods) and TestContext (12 methods) covering Args defaults, as_dict serialization with OrderedDict key order and None-to-string conversion, Context constructor attribute storage, create_child_context shallow copy with child logger, and print_to_log logger.debug calls.
  test_types.py has TestOverrides (8 methods) covering valid overrides (direct, inherited, unittest.TestCase), method callability after decoration, and failure cases (non-class string/int/function, non-existent method) with correct AssertionError messages.
  All 721+ existing tests pass with zero regressions. All 5 new test files pass together.
  </done>
</task>

</tasks>

<verification>
Phase-level verification after both tasks complete:

1. **All 5 test files exist:**
   `ls src/python/tests/unittests/test_common/test_constants.py src/python/tests/unittests/test_common/test_context.py src/python/tests/unittests/test_common/test_error.py src/python/tests/unittests/test_common/test_localization.py src/python/tests/unittests/test_common/test_types.py`

2. **New tests pass in isolation:**
   `cd src/python && poetry run pytest tests/unittests/test_common/test_constants.py tests/unittests/test_common/test_context.py tests/unittests/test_common/test_error.py tests/unittests/test_common/test_localization.py tests/unittests/test_common/test_types.py -v`
   Expected: ~40 tests, all passing.

3. **Zero regressions in full suite:**
   `cd src/python && poetry run pytest -q`
   Expected: 721+ tests total (existing + new), same pre-existing failure count as Phase 15 baseline (586 passed, 75 failed, 56 errors, 8 skipped -- all pre-existing).

4. **Coverage improved:**
   `cd src/python && poetry run pytest --cov --cov-report=term -q 2>&1 | grep "TOTAL"`
   Expected: Total coverage >= 77% (Phase 15 baseline), with constants.py/context.py/error.py/localization.py/types.py all showing increased coverage.

5. **Copyright headers present:**
   Each file starts with `# Copyright 2017, Inderpreet Singh, All rights reserved.`

6. **Correct test patterns:**
   All tests use unittest.TestCase classes, `from common import ...` imports, and @overrides on setUp where applicable.
</verification>

<success_criteria>
- 5 new test files exist in src/python/tests/unittests/test_common/
- ~40 test methods across ~7 test classes covering all public APIs
- constants.py: All 8 constants tested for value, type, and positivity where applicable
- context.py: Args defaults, as_dict() OrderedDict serialization, Context constructor, create_child_context shallow copy, print_to_log
- error.py: AppError/ServiceExit/ServiceRestart inheritance chain, catch semantics, message preservation, mutual exclusion
- localization.py: All 5 error strings tested for existence, type, format placeholder substitution
- types.py: @overrides success cases (direct, inherited, unittest.TestCase) and failure cases (non-class, non-existent method) with error messages
- All new tests pass
- All 721+ existing tests still pass (zero regressions)
- Coverage >= 77% baseline
</success_criteria>

<output>
After completion, create `.planning/phases/16-common-module-tests/16-01-SUMMARY.md`

The SUMMARY must include:
- Exact count of new test methods added
- Exact count of assertions
- Full test suite pass/fail counts (showing zero new regressions)
- Coverage numbers for the 5 tested modules specifically
- Any deviations from plan
</output>
