---
phase: 25-auto-delete-with-safety
plan: 02
type: execute
wave: 2
depends_on: ["25-01"]
files_modified:
  - src/python/controller/controller.py
autonomous: true

must_haves:
  truths:
    - "When Sonarr import detected and auto-delete enabled, local file deletion is scheduled after delay_seconds"
    - "When dry-run enabled, log message says what would be deleted but file is NOT deleted"
    - "Auto-delete only calls delete_local(), NEVER delete_remote()"
    - "Pending timers are canceled on controller exit (no timer leak)"
    - "Re-detection of same file cancels old timer and schedules new one"
    - "If auto-delete disabled mid-flight, timer callback checks config and skips deletion"
    - "If file no longer in model when timer fires, error is handled gracefully"
  artifacts:
    - path: "src/python/controller/controller.py"
      provides: "Auto-delete scheduling, execution, cancellation, shutdown cleanup"
      contains: "__schedule_auto_delete"
  key_links:
    - from: "src/python/controller/controller.py"
      to: "src/python/controller/file_operation_manager.py"
      via: "__execute_auto_delete calls self.__file_op_manager.delete_local()"
      pattern: "self\\.__file_op_manager\\.delete_local"
    - from: "src/python/controller/controller.py"
      to: "src/python/common/config.py"
      via: "reads self.__context.config.autodelete.enabled/dry_run/delay_seconds"
      pattern: "self\\.__context\\.config\\.autodelete"
    - from: "src/python/controller/controller.py __check_sonarr_imports"
      to: "src/python/controller/controller.py __schedule_auto_delete"
      via: "import detection triggers auto-delete scheduling"
      pattern: "__schedule_auto_delete"
---

<objective>
Implement timer-based auto-delete logic in Controller: schedule deletion after import detection, handle dry-run mode, cancel timers on shutdown, and add safety checks.

Purpose: Core auto-delete feature. When Sonarr imports a file, Controller schedules its local deletion after a configurable safety delay. Multiple safety mechanisms prevent data loss.
Output: Controller with __pending_auto_deletes dict, __schedule_auto_delete, __execute_auto_delete, and timer cleanup in exit().
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-auto-delete-with-safety/25-RESEARCH.md
@.planning/phases/25-auto-delete-with-safety/25-01-SUMMARY.md
@src/python/controller/controller.py
@src/python/controller/file_operation_manager.py
@src/python/common/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add auto-delete scheduling and execution to Controller</name>
  <files>src/python/controller/controller.py</files>
  <action>
In `src/python/controller/controller.py`:

1. Add `import threading` at the top imports (stdlib, add near `from threading import Lock`). Change the existing `from threading import Lock` to `import threading` and update the Lock usage to `threading.Lock()` -- OR keep `from threading import Lock` and add `import threading` separately. Either way, `threading.Timer` must be accessible.

2. Add `from typing import Dict` if not already imported (check existing imports -- `List, Optional, Tuple` are imported, add `Dict`).

3. In `Controller.__init__`, after the memory monitor registration block (after `self.__started = False`), add:
   ```python
   # Pending auto-delete timers: file_name -> Timer
   self.__pending_auto_deletes: Dict[str, threading.Timer] = {}
   ```
   Place this BEFORE `self.__started = False` so it's initialized with other state.

4. In `Controller.__check_sonarr_imports()`, at the end of the `for file_name in newly_imported:` loop (after the `except ModelError: pass` block), add:
   ```python
   # Schedule auto-delete if enabled
   if self.__context.config.autodelete.enabled:
       self.__schedule_auto_delete(file_name)
   ```
   This reads config each time (hot-toggle support -- same pattern as SonarrManager).

5. Add `__schedule_auto_delete` method to Controller (place after `__check_sonarr_imports`):
   ```python
   def __schedule_auto_delete(self, file_name: str):
       """Schedule auto-delete of local file after safety delay."""
       # Cancel existing timer if file was re-detected
       if file_name in self.__pending_auto_deletes:
           self.__pending_auto_deletes[file_name].cancel()
           del self.__pending_auto_deletes[file_name]

       delay = self.__context.config.autodelete.delay_seconds
       timer = threading.Timer(delay, self.__execute_auto_delete, args=[file_name])
       timer.daemon = True  # Don't prevent process exit
       self.__pending_auto_deletes[file_name] = timer
       timer.start()
       self.logger.info(
           "Scheduled auto-delete of '{}' in {} seconds".format(file_name, delay)
       )
   ```
   IMPORTANT: Set `timer.daemon = True` so timers don't prevent clean shutdown even if cancel() is missed.

6. Add `__execute_auto_delete` method (place after `__schedule_auto_delete`):
   ```python
   def __execute_auto_delete(self, file_name: str):
       """Execute auto-delete of local file (called by Timer after delay)."""
       # Remove from tracking dict
       self.__pending_auto_deletes.pop(file_name, None)

       # Re-check config -- user might have disabled auto-delete after timer was scheduled
       if not self.__context.config.autodelete.enabled:
           self.logger.info(
               "Auto-delete skipped for '{}': feature was disabled".format(file_name)
           )
           return

       # Check dry-run mode
       if self.__context.config.autodelete.dry_run:
           self.logger.info(
               "DRY-RUN: Would delete local file '{}'".format(file_name)
           )
           return

       # Get file from model and delete local copy
       # SAFETY: ONLY call delete_local(), NEVER delete_remote()
       try:
           file = self.__model.get_file(file_name)
           self.__file_op_manager.delete_local(file)
           self.logger.info("Auto-deleted local file '{}'".format(file_name))
       except ModelError:
           self.logger.debug(
               "File '{}' no longer in model, skipping auto-delete".format(file_name)
           )
   ```
   CRITICAL SAFETY: This method ONLY calls `self.__file_op_manager.delete_local(file)`. There must be NO reference to `delete_remote` anywhere in auto-delete code.

7. In `Controller.exit()`, add timer cleanup BEFORE the existing manager stop calls (before `self.__lftp_manager.exit()`):
   ```python
   # Cancel all pending auto-delete timers
   for file_name, timer in list(self.__pending_auto_deletes.items()):
       timer.cancel()
       self.logger.debug("Canceled pending auto-delete for '{}'".format(file_name))
   self.__pending_auto_deletes.clear()
   ```
   Using `list()` to copy items since we're modifying the dict.

SAFETY REVIEW CHECKLIST (verify these are true in the final code):
- [ ] __execute_auto_delete calls ONLY delete_local, NEVER delete_remote
- [ ] __execute_auto_delete checks config.autodelete.enabled before deletion
- [ ] __execute_auto_delete checks config.autodelete.dry_run before deletion
- [ ] __execute_auto_delete catches ModelError if file no longer exists
- [ ] exit() cancels all pending timers
- [ ] timer.daemon = True set on all timers
- [ ] __schedule_auto_delete cancels existing timer for same file before scheduling new one
  </action>
  <verify>
Run existing Python tests to ensure no regressions: `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/ -x -q 2>&1 | tail -20`

Verify the code compiles: `cd /Users/julianamacbook/seedsync/src/python && poetry run python -c "from controller import Controller; print('import ok')"` -- should print "import ok".

Manually verify safety: `cd /Users/julianamacbook/seedsync/src/python && poetry run python -c "
import ast, inspect
from controller.controller import Controller
source = inspect.getsource(Controller)
# Verify delete_remote is NOT called in auto-delete methods
tree = ast.parse(source)
print('Safety check: searching for delete_remote in auto-delete methods...')
found_danger = False
for node in ast.walk(tree):
    if isinstance(node, ast.Attribute) and 'delete_remote' in getattr(node, 'attr', ''):
        # Check if this is inside an auto_delete method
        print('WARNING: Found delete_remote reference')
        found_danger = True
if not found_danger:
    print('SAFE: No delete_remote calls found in controller source via auto-delete path')
"` -- should print SAFE message. Note: delete_remote exists in __handle_delete_remote_command which is fine; verify manually that __execute_auto_delete only calls delete_local.
  </verify>
  <done>Controller.__check_sonarr_imports schedules auto-delete when enabled. __schedule_auto_delete creates threading.Timer with configurable delay. __execute_auto_delete checks enabled + dry_run flags, calls ONLY delete_local(). exit() cancels all pending timers. All existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for auto-delete scheduling, execution, and safety</name>
  <files>src/python/tests/unittests/test_controller/test_auto_delete.py</files>
  <action>
Create `src/python/tests/unittests/test_controller/test_auto_delete.py` with unit tests for auto-delete behavior.

First, check if `src/python/tests/unittests/test_controller/` directory exists and has an `__init__.py`. If the directory doesn't exist, create it with an empty `__init__.py`. Look at existing test patterns in `src/python/tests/unittests/` for import conventions.

The tests should use mocking to isolate Controller auto-delete logic. Key test cases:

```python
import unittest
from unittest.mock import MagicMock, patch, PropertyMock
import threading
import time

from controller.controller import Controller
from model import ModelFile, ModelError


class TestAutoDeleteScheduling(unittest.TestCase):
    """Test auto-delete scheduling from __check_sonarr_imports."""

    def _create_controller_with_mocks(self, autodelete_enabled=True, dry_run=False, delay_seconds=1):
        """Helper to create a Controller with mocked dependencies."""
        # Mock context
        context = MagicMock()
        context.config.autodelete.enabled = autodelete_enabled
        context.config.autodelete.dry_run = dry_run
        context.config.autodelete.delay_seconds = delay_seconds
        context.config.sonarr.enabled = False
        context.logger = MagicMock()
        context.logger.getChild.return_value = MagicMock()

        # Mock persist
        persist = MagicMock()
        persist.downloaded_file_names = MagicMock()
        persist.downloaded_file_names.__len__ = MagicMock(return_value=0)
        persist.downloaded_file_names.total_evictions = 0
        persist.extracted_file_names = MagicMock()
        persist.extracted_file_names.__len__ = MagicMock(return_value=0)
        persist.extracted_file_names.total_evictions = 0
        persist.stopped_file_names = MagicMock()
        persist.stopped_file_names.__len__ = MagicMock(return_value=0)
        persist.stopped_file_names.total_evictions = 0
        persist.imported_file_names = MagicMock()
        persist.imported_file_names.__len__ = MagicMock(return_value=0)
        persist.imported_file_names.total_evictions = 0

        return context, persist

    def test_pending_auto_deletes_initialized_empty(self):
        """Verify __pending_auto_deletes dict exists and starts empty."""
        context, persist = self._create_controller_with_mocks()
        controller = Controller(context, persist)
        # Access private attribute for testing
        self.assertEqual({}, controller._Controller__pending_auto_deletes)

    def test_schedule_creates_timer(self):
        """Verify scheduling creates a timer entry."""
        context, persist = self._create_controller_with_mocks(delay_seconds=10)
        controller = Controller(context, persist)
        controller._Controller__schedule_auto_delete("test_file.mkv")
        self.assertIn("test_file.mkv", controller._Controller__pending_auto_deletes)
        timer = controller._Controller__pending_auto_deletes["test_file.mkv"]
        self.assertIsInstance(timer, threading.Timer)
        timer.cancel()  # Cleanup

    def test_schedule_cancels_existing_timer(self):
        """Verify re-scheduling cancels the old timer."""
        context, persist = self._create_controller_with_mocks(delay_seconds=10)
        controller = Controller(context, persist)
        controller._Controller__schedule_auto_delete("test_file.mkv")
        old_timer = controller._Controller__pending_auto_deletes["test_file.mkv"]
        controller._Controller__schedule_auto_delete("test_file.mkv")
        new_timer = controller._Controller__pending_auto_deletes["test_file.mkv"]
        self.assertIsNot(old_timer, new_timer)
        # Old timer should be canceled
        self.assertTrue(old_timer.finished.is_set() or not old_timer.is_alive())
        new_timer.cancel()  # Cleanup


class TestAutoDeleteExecution(unittest.TestCase):
    """Test auto-delete execution (timer callback)."""

    def _create_controller_with_mocks(self, autodelete_enabled=True, dry_run=False, delay_seconds=1):
        context = MagicMock()
        context.config.autodelete.enabled = autodelete_enabled
        context.config.autodelete.dry_run = dry_run
        context.config.autodelete.delay_seconds = delay_seconds
        context.config.sonarr.enabled = False
        context.logger = MagicMock()
        context.logger.getChild.return_value = MagicMock()

        persist = MagicMock()
        persist.downloaded_file_names = MagicMock()
        persist.downloaded_file_names.__len__ = MagicMock(return_value=0)
        persist.downloaded_file_names.total_evictions = 0
        persist.extracted_file_names = MagicMock()
        persist.extracted_file_names.__len__ = MagicMock(return_value=0)
        persist.extracted_file_names.total_evictions = 0
        persist.stopped_file_names = MagicMock()
        persist.stopped_file_names.__len__ = MagicMock(return_value=0)
        persist.stopped_file_names.total_evictions = 0
        persist.imported_file_names = MagicMock()
        persist.imported_file_names.__len__ = MagicMock(return_value=0)
        persist.imported_file_names.total_evictions = 0

        return context, persist

    def test_execute_calls_delete_local(self):
        """Verify execution calls delete_local (not delete_remote)."""
        context, persist = self._create_controller_with_mocks()
        controller = Controller(context, persist)
        mock_file = MagicMock(spec=ModelFile)
        controller._Controller__model.get_file = MagicMock(return_value=mock_file)
        controller._Controller__file_op_manager = MagicMock()

        controller._Controller__execute_auto_delete("test_file.mkv")

        controller._Controller__file_op_manager.delete_local.assert_called_once_with(mock_file)
        controller._Controller__file_op_manager.delete_remote.assert_not_called()

    def test_execute_dry_run_does_not_delete(self):
        """Verify dry-run mode logs but does not delete."""
        context, persist = self._create_controller_with_mocks(dry_run=True)
        controller = Controller(context, persist)
        controller._Controller__file_op_manager = MagicMock()

        controller._Controller__execute_auto_delete("test_file.mkv")

        controller._Controller__file_op_manager.delete_local.assert_not_called()

    def test_execute_disabled_skips_deletion(self):
        """Verify disabled config skips deletion even if timer fires."""
        context, persist = self._create_controller_with_mocks(autodelete_enabled=False)
        controller = Controller(context, persist)
        controller._Controller__file_op_manager = MagicMock()

        controller._Controller__execute_auto_delete("test_file.mkv")

        controller._Controller__file_op_manager.delete_local.assert_not_called()

    def test_execute_handles_model_error(self):
        """Verify ModelError is caught gracefully when file no longer exists."""
        context, persist = self._create_controller_with_mocks()
        controller = Controller(context, persist)
        controller._Controller__model.get_file = MagicMock(side_effect=ModelError("not found"))
        controller._Controller__file_op_manager = MagicMock()

        # Should not raise
        controller._Controller__execute_auto_delete("test_file.mkv")

        controller._Controller__file_op_manager.delete_local.assert_not_called()

    def test_execute_removes_from_pending_dict(self):
        """Verify execution removes file from pending dict."""
        context, persist = self._create_controller_with_mocks()
        controller = Controller(context, persist)
        mock_file = MagicMock(spec=ModelFile)
        controller._Controller__model.get_file = MagicMock(return_value=mock_file)
        controller._Controller__file_op_manager = MagicMock()
        controller._Controller__pending_auto_deletes["test_file.mkv"] = MagicMock()

        controller._Controller__execute_auto_delete("test_file.mkv")

        self.assertNotIn("test_file.mkv", controller._Controller__pending_auto_deletes)


class TestAutoDeleteShutdown(unittest.TestCase):
    """Test timer cleanup on controller exit."""

    def _create_controller_with_mocks(self, delay_seconds=60):
        context = MagicMock()
        context.config.autodelete.enabled = True
        context.config.autodelete.dry_run = False
        context.config.autodelete.delay_seconds = delay_seconds
        context.config.sonarr.enabled = False
        context.logger = MagicMock()
        context.logger.getChild.return_value = MagicMock()

        persist = MagicMock()
        persist.downloaded_file_names = MagicMock()
        persist.downloaded_file_names.__len__ = MagicMock(return_value=0)
        persist.downloaded_file_names.total_evictions = 0
        persist.extracted_file_names = MagicMock()
        persist.extracted_file_names.__len__ = MagicMock(return_value=0)
        persist.extracted_file_names.total_evictions = 0
        persist.stopped_file_names = MagicMock()
        persist.stopped_file_names.__len__ = MagicMock(return_value=0)
        persist.stopped_file_names.total_evictions = 0
        persist.imported_file_names = MagicMock()
        persist.imported_file_names.__len__ = MagicMock(return_value=0)
        persist.imported_file_names.total_evictions = 0

        return context, persist

    def test_exit_cancels_all_pending_timers(self):
        """Verify exit() cancels all pending auto-delete timers."""
        context, persist = self._create_controller_with_mocks(delay_seconds=60)
        controller = Controller(context, persist)

        # Schedule some timers
        controller._Controller__schedule_auto_delete("file1.mkv")
        controller._Controller__schedule_auto_delete("file2.mkv")
        self.assertEqual(2, len(controller._Controller__pending_auto_deletes))

        # Mark as started so exit() runs cleanup (need to mock managers)
        controller._Controller__started = True
        controller._Controller__lftp_manager = MagicMock()
        controller._Controller__scan_manager = MagicMock()
        controller._Controller__file_op_manager = MagicMock()
        controller._Controller__mp_logger = MagicMock()

        controller.exit()

        self.assertEqual(0, len(controller._Controller__pending_auto_deletes))
```

IMPORTANT notes for the test file:
- The exact mock setup may need adjustment based on Controller.__init__ requirements. Read Controller.__init__ carefully to understand what the mocks need to provide.
- If Controller.__init__ instantiates managers internally (not via injection), you may need to patch the constructors. Check if ScanManager, LftpManager, FileOperationManager, SonarrManager are created in __init__ or passed as params.
- The Controller takes (context, persist) as constructor args. Managers are created internally. You'll need to patch the manager constructors to prevent real initialization. Use `@patch('controller.controller.ScanManager')`, `@patch('controller.controller.LftpManager')`, etc. as class-level decorators.
- Look at existing test files in `tests/` for the project's preferred mocking approach.
- The test class names and methods above are guidelines -- adapt them to work with the actual Controller constructor requirements. The KEY behaviors to test are what's listed; how you mock is implementation detail.
  </action>
  <verify>
Run the new tests: `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/unittests/test_controller/test_auto_delete.py -v 2>&1 | tail -30` -- all tests should pass.

Run the full test suite to check for regressions: `cd /Users/julianamacbook/seedsync/src/python && poetry run pytest tests/ -x -q 2>&1 | tail -10` -- all tests should pass.
  </verify>
  <done>Unit tests verify: (1) scheduling creates timers, (2) re-scheduling cancels old timer, (3) execution calls delete_local only, (4) dry-run does not delete, (5) disabled config skips deletion, (6) ModelError handled gracefully, (7) exit cancels all timers. All tests pass, no regressions.</done>
</task>

</tasks>

<verification>
1. Auto-delete scheduling: Import detection with autodelete.enabled=True creates timer entry
2. Safety - delete_local only: __execute_auto_delete NEVER references delete_remote
3. Safety - dry-run: When dry_run=True, log message emitted but no deletion
4. Safety - disabled mid-flight: When enabled=False at timer fire time, deletion skipped
5. Safety - file gone: ModelError caught gracefully, no crash
6. Shutdown cleanup: exit() cancels all pending timers, dict cleared
7. All existing tests pass (no regressions)
8. All new tests pass
</verification>

<success_criteria>
- Controller.__pending_auto_deletes dict tracks active timers
- __check_sonarr_imports calls __schedule_auto_delete when autodelete.enabled is True
- __schedule_auto_delete creates daemon Timer with configurable delay, cancels existing timer for same file
- __execute_auto_delete checks enabled + dry_run before calling delete_local ONLY
- exit() cancels all pending timers
- Unit tests cover all 7 safety/behavior scenarios
- All tests (new + existing) pass
</success_criteria>

<output>
After completion, create `.planning/phases/25-auto-delete-with-safety/25-02-SUMMARY.md`
</output>
